import React, { useState, useEffect } from "react";
import "../Styles/dropdowns.css";
import * as XLSX from 'xlsx';


const EditUploadTableAnalysis = () => {
  const [problemsByYear, setProblemsByYear] = useState({});
  const [availableYears, setAvailableYears] = useState([]);
  const [selectedYears, setSelectedYears] = useState([]);
  const [dropdownOpen, setDropdownOpen] = useState(false);
  const [editMode, setEditMode] = useState(false);
  const [originalValues, setOriginalValues] = useState({});
  const [newRows, setNewRows] = useState([]); // State untuk menyimpan baris-baris data baru

  useEffect(() => {
    fetchMasalahData();
  }, []);

  const fetchMasalahData = async () => {
    try {
      const response = await fetch("http://localhost:8080/kpi/masalah");
      if (response.ok) {
        const responseData = await response.json();
        const data = responseData.data;
        console.log("Received data:", data);

        // Group problems by year
        const groupedProblems = {};
        data.forEach(problem => {
          if (!groupedProblems[problem.Year]) {
            groupedProblems[problem.Year] = [];
          }
          groupedProblems[problem.Year].push(problem);
        });

        setProblemsByYear(groupedProblems);

        // Extract available years
        const years = Object.keys(groupedProblems);
        setAvailableYears(years);
        setSelectedYears(years); // Initially select all years
      } else {
        console.error("Failed to fetch masalah data:", response.statusText);
      }
    } catch (error) {
      console.error("Error fetching masalah data:", error);
    }
  };

  const [selectedFile, setSelectedFile] = useState(null);
  const [fileData, setFileData] = useState(null);

  // This function handles file selection
  const handleFileChange = (event) => {
    const file = event.target.files[0];
    console.log('File selected:', file); // Log the selected file
    setSelectedFile(file); // Set the selected file to the state

    // Read the file data for preview purposes (optional)
    if (file) {
      const reader = new FileReader();
      reader.onload = (event) => {
        const workbook = XLSX.read(event.target.result, { type: 'binary' });
        const sheetName = workbook.SheetNames[0];
        const sheet = workbook.Sheets[sheetName];
        const data = XLSX.utils.sheet_to_json(sheet);
        setFileData(data); // Store parsed data for preview
      };
      reader.readAsBinaryString(file);
    }
  };

  // This function handles file upload
  const handleFileUpload = async () => {
    if (selectedFile) { // Check if a file is selected
      try {
        console.log('Preparing to upload file:', selectedFile); // Log before uploading

        const formData = new FormData();
        formData.append('file', selectedFile); // Append the actual file to FormData

        const response = await fetch('http://localhost:8080/kpi/file/analisa', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('authToken')}`,
            // 'Content-Type' is not needed; 'fetch' sets it automatically when FormData is used.
          },
          body: formData // Send the FormData containing the file
        });

        if (response.ok) {
          console.log('File uploaded successfully'); // Log success
          alert('File berhasil diunggah dan data diproses');
          // Handle further actions if necessary
        } else {
          const errorText = await response.text();
          console.error('Failed to upload file:', errorText); // Log the error message
          alert(`Gagal mengunggah file: ${errorText}`);
        }
      } catch (error) {
        console.error('Error uploading file:', error); // Log the error
        alert('Error uploading file: ' + error.message);
      }
    } else {
      alert('Harap pilih file terlebih dahulu');
    }
  };

  const toggleDropdown = () => {
    setDropdownOpen(!dropdownOpen);
  };

  const handleYearChange = (year) => {
    const updatedSelectedYears = selectedYears.includes(year)
      ? selectedYears.filter(selectedYear => selectedYear !== year)
      : [...selectedYears, year];
    setSelectedYears(updatedSelectedYears);
  };

  // Definisi fetchData
const fetchData = async () => {
  try {
    // Lakukan permintaan fetch data yang diperlukan dari server
    const response = await fetch("http://localhost:8080/kpi/masalah");
    if (response.ok) {
      const responseData = await response.json();
      const data = responseData.data;
      console.log("Received data:", data);

      // Group problems by year
      const groupedProblems = {};
      data.forEach(problem => {
        if (!groupedProblems[problem.Year]) {
          groupedProblems[problem.Year] = [];
        }
        groupedProblems[problem.Year].push(problem);
      });

      // Setel state dengan data yang baru didapat
      setProblemsByYear(groupedProblems);

      // Extract available years
      const years = Object.keys(groupedProblems);
      setAvailableYears(years);
      setSelectedYears(years); // Initially select all years
    } else {
      console.error("Failed to fetch masalah data:", response.statusText);
    }
  } catch (error) {
    console.error("Error fetching masalah data:", error);
  }
};


  const handleDeleteAllData = async (year) => {
    if (window.confirm(`Apakah Anda yakin ingin menghapus semua data pada tahun ${year}?`)) {
      try {
        const authToken = localStorage.getItem("authToken");
  
        // Ambil masalah_id untuk semua masalah pada tahun yang dipilih
        const masalahIds = problemsByYear[year].map(problem => problem.Masalah_ID);
  
        // Buat array of promises untuk mengirim permintaan DELETE untuk setiap masalah_id
        const deleteRequests = masalahIds.map(masalahId =>
          fetch(`http://localhost:8080/kpi/masalah/${masalahId}`, {
            method: "DELETE",
            headers: {
              Authorization: `Bearer ${authToken}`,
            },
          })
        );
  
        // Lakukan penghapusan data dengan Promise.all
        const responses = await Promise.all(deleteRequests);
  
        // Periksa apakah semua permintaan berhasil
        const allSucceeded = responses.every(response => response.ok);
  
        if (allSucceeded) {
          console.log('All data deleted successfully');
          fetchData(); // Refresh data after deletion
        } else {
          throw new Error("Failed to delete all data");
        }
      } catch (error) {
        console.error("Error deleting all data:", error.message);
      }
    }
  };
  

  const handleDeleteRowClick = async (year, index, masalahID) => {
    const userConfirmed = window.confirm("Apakah anda yakin ingin menghapus row ini?");
    if (!userConfirmed) {
      return; // Exit the function if the user cancels the deletion
    }
    try {
      const authToken = localStorage.getItem("authToken");
      const response = await fetch(`http://localhost:8080/kpi/masalah/${masalahID}`, {
        method: "DELETE",
        headers: {
          "Authorization": `Bearer ${authToken}`
        }
      });
      if (response.ok) {
        const updatedProblems = [...problemsByYear[year]];
        updatedProblems.splice(index, 1);
        setProblemsByYear({
          ...problemsByYear,
          [year]: updatedProblems
        });
        console.log("Row deleted successfully");
      } else {
        console.error("Failed to delete row:", response.statusText);
      }
    } catch (error) {
      console.error("Error deleting row:", error);
    }
  };

  

  const handleDeleteNewRowClick = (year, index) => {
    const userConfirmed = window.confirm("Apakah anda yakin ingin menghapus row ini?");
    if (!userConfirmed) {
      return; // Exit the function if the user cancels the deletion
    }
    setNewRows(prevState => ({
      ...prevState,
      [year]: prevState[year].filter((_, idx) => idx !== index)
    }));
  };

  const handleEditClick = () => {
    setEditMode(true);
    const originalValuesCopy = {};
    selectedYears.forEach(year => {
      originalValuesCopy[year] = [...problemsByYear[year]];
    });
    setOriginalValues(originalValuesCopy);

    // Inisialisasi objek baris baru untuk setiap tahun yang dipilih
    const newRowsCopy = {};
    selectedYears.forEach(year => {
      newRowsCopy[year] = [];
    });
    setNewRows(newRowsCopy);
  };

  const handleAddRowClick = (year) => {
    const newRow = {
      Masalah: "",
      Why: ["", "", "", "", ""],
      Tindakan: "",
      Pic: "",
      Target: "",
      FolDate: "",
      Status: "",
      Year: year
    };

    setNewRows(prevState => ({
      ...prevState,
      [year]: [...(prevState[year] || []), newRow]
    }));
  };

  const handleSaveClick = async () => {
    const authToken = localStorage.getItem('authToken');
  
    try {
      const promises = [];
  
      selectedYears.forEach(year => {
        const updatedProblems = problemsByYear[year];
        updatedProblems.forEach(problem => {
          const formData = {
            Masalah_ID: problem.Masalah_ID,
            Masalah: problem.Masalah,
            Why: problem.Why,
            tindakan: problem.Tindakan,
            pic: problem.Pic,
            target: problem.Target,
            folDate: new Date(problem.FolDate).toISOString(),
            status: problem.Status,
            Year: problem.Year
          };
          
          console.log("Data yang dikirim ke server:", formData); // Tambahkan console log untuk body JSON
  
          promises.push(fetch(`http://localhost:8080/kpi/masalah/${problem.Masalah_ID}`, {
            method: "PUT",
            headers: {
              'Content-Type': 'application/json',
              "Authorization": `Bearer ${authToken}`
            },
            body: JSON.stringify(formData)
          }));
        });
  
        // Tambahkan data baru ke promises untuk dikirim ke server
      // Tambahkan data baru ke promises untuk dikirim ke server
      const newRowsForYear = newRows[year] || [];
      newRowsForYear.forEach(newRow => {
        const { Masalah_ID, ...formDataWithoutID } = newRow; // Destructure and remove Masalah_ID
        const formData = {
          ...formDataWithoutID,
          Why: [
            newRow.Why[0],
            newRow.Why[1],
            newRow.Why[2],
            newRow.Why[3],
            newRow.Why[4],
          ],
          FolDate: new Date(newRow.FolDate).toISOString(), // Ensure FolDate is converted to ISO string format
          Year: parseInt(newRow.Year) // Ensure Year is sent as an integer
        };
        
  console.log("Data yang dikirim ke server:", formData); // Tambahkan console log untuk body JSON

  promises.push(fetch(`http://localhost:8080/kpi/masalah`, {
    method: "POST",
    headers: {
      'Content-Type': 'application/json',
      "Authorization": `Bearer ${authToken}`
    },
    body: JSON.stringify(formData)
  }));
});

      });
  
      await Promise.all(promises);
      setEditMode(false);
      console.log("Data saved successfully.");
      fetchMasalahData(); // Refresh data setelah penyimpanan
     setProblemsByYear({});
    setNewRows({});
    } catch (error) {
      console.error("Failed to save data:", error);
    }
  };

  
  

        return (
          <div>
            <div className="container">
               <div style={{marginBottom:"10px"}} className="filter-containers">
              <div className="dropdown">
            <button onClick={toggleDropdown} className="dropdown-button">
              Filter Tahun
            </button>
            {dropdownOpen && (
              <div className="dropdown-content">
                {availableYears.map((year, index) => (
                  <label key={index} className="dropdown-item">
                    <input
                      type="checkbox"
                      value={year}
                      checked={selectedYears.includes(year)}
                      onChange={() => handleYearChange(year)}
                    />
                    {year}
                  </label>
                ))}
              </div>
            )}

            
          </div>

          
          
          <div className="savechanges">
            {!editMode && (
              <button onClick={handleEditClick}>Update Data Table</button>
            )}
          
            {editMode && (
              <button onClick={handleSaveClick}>Save Changes</button>
            )}
            </div>
    
           </div>

          
       </div>

       
       <div className='inputfile' style={{ marginLeft:"22px", display: 'flex', alignItems: 'center', marginBottom: '5px',  width: 'calc(100% - 43px)'}}>
  <input type="file" onChange={handleFileChange} style={{ marginRight: '13px' }} />
  <button onClick={handleFileUpload} style={{ padding: '5px 10px', borderRadius: '5px', backgroundImage: 'linear-gradient(to right, rgb(26, 171, 0), rgb(12, 217, 29))', color: 'white', border: 'none',  marginRight:"3px" }}>Upload Data</button>
</div>



      {selectedYears.map(year => (
        <div key={year} className="table-containers">
          <table className="dropdowns-safety">
            <caption>Saved Analysis Table for {year}</caption>
            <thead>
              <tr>
                <th rowSpan="2">Problem
                <div className="savechanges">

                <div>
                  {editMode && (
                    <button onClick={() => handleAddRowClick(year)}>Add</button>
                  )}
                  </div>
                  </div>

                </th>
                <th colSpan="5">Causes Analysis</th>
                <th rowSpan="2">Corrective Action</th>
                <th rowSpan="2">PIC</th>
                <th rowSpan="2">Target</th>
                <th colSpan="2">Follow Up</th>
              </tr>
              <tr>
                <th>Why 1</th>
                <th>Why 2</th>
                <th>Why 3</th>
                <th>Why 4</th>
                <th>Why 5</th>
                <th>Date</th>
                <th>Status</th>
              </tr>
            </thead>
            <tbody>
              {(problemsByYear[year] || []).map((problem, index) => (
                <tr key={`${year}_${index}_${problem.Masalah_ID || ''}`}>
                  <td>
                  <div className="delete">

                    {editMode ? (
                      <textarea
                        value={problem.Masalah || ""}
                        onChange={e => {
                          const updatedProblems = [...problemsByYear[year]];
                          const updatedProblem = { ...problem };
                          updatedProblem.Masalah = e.target.value;
                          updatedProblems[index] = updatedProblem;

                          setProblemsByYear({
                            ...problemsByYear,
                            [year]: updatedProblems
                          });
                        }}
                        style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                        placeholder={problem.Masalah}
                      />
                    ) : (
                      problem.Masalah
                    )}
                    <div>
                 {editMode && (
                    <button onClick={() => handleDeleteRowClick(year, index, problem.Masalah_ID)}>Delete</button>
                  )}
                  </div>
                  </div>
                  </td>
                  <td>
                    {editMode ? (
                      <textarea
                        value={problem.Why[0]}
                        onChange={e => {
                          const updatedProblems = [...problemsByYear[year]];
                          updatedProblems[index].Why[0] = e.target.value;
                          setProblemsByYear({
                            ...problemsByYear,
                            [year]: updatedProblems
                          });
                          
                        }}
                        style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                        placeholder={problem.Why[0]}
                      />
                      
                    ) : (
                      problem.Why[0]
                    )}
                  </td>
                  <td>
                    {editMode ? (
                      <textarea
                        value={problem.Why[1]}
                        onChange={e => {
                          const updatedProblems = [...problemsByYear[year]];
                          updatedProblems[index].Why[1] = e.target.value;
                          setProblemsByYear({
                            ...problemsByYear,
                            [year]: updatedProblems
                          });
                        }}
                        style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                        placeholder={problem.Why[1]}
                      />
                    ) : (
                      problem.Why[1]
                    )}
                  </td>
                  <td>
                    {editMode ? (
                      <textarea
                        value={problem.Why[2]}
                        onChange={e => {
                          const updatedProblems = [...problemsByYear[year]];
                          updatedProblems[index].Why[2] = e.target.value;
                          setProblemsByYear({
                            ...problemsByYear,
                            [year]: updatedProblems
                          });
                        }}
                        style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                        placeholder={problem.Why[2]}
                      />
                    ) : (
                      problem.Why[2]
                    )}
                  </td>
                  <td>
                    {editMode ? (
                      <textarea
                        value={problem.Why[3]}
                        onChange={e => {
                          const updatedProblems = [...problemsByYear[year]];
                          updatedProblems[index].Why[3] = e.target.value;
                          setProblemsByYear({
                            ...problemsByYear,
                            [year]: updatedProblems
                          });
                        }}
                        style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                        placeholder={problem.Why[3]}
                      />
                    ) : (
                      problem.Why[3]
                    )}
                  </td>
                  <td>
                    {editMode ? (
                      <textarea
                        value={problem.Why[4]}
                        onChange={e => {
                          const updatedProblems = [...problemsByYear[year]];
                          updatedProblems[index].Why[4] = e.target.value;
                          setProblemsByYear({
                            ...problemsByYear,
                            [year]: updatedProblems
                          });
                        }}
                        style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                        placeholder={problem.Why[4]}
                      />
                    ) : (
                      problem.Why[4]
                    )}
                  </td>
                  <td>
                    {editMode ? (
                      <textarea
                        value={problem.Tindakan}
                        onChange={e => {
                          const updatedProblems = [...problemsByYear[year]];
                          updatedProblems[index].Tindakan = e.target.value;
                          setProblemsByYear({
                            ...problemsByYear,
                            [year]: updatedProblems
                          });
                        }}
                        style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                        placeholder={problem.Tindakan}
                      />
                    ) : (
                      problem.Tindakan
                    )}
                  </td>
                  <td>
                    {editMode ? (
                      <textarea
                        value={problem.Pic}
                        onChange={e => {
                          const updatedProblems = [...problemsByYear[year]];
                          updatedProblems[index].Pic = e.target.value;
                          setProblemsByYear({
                            ...problemsByYear,
                            [year]: updatedProblems
                          });
                        }}
                        style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                        placeholder={problem.Pic}
                      />
                    ) : (
                      problem.Pic
                    )}
                  </td>
                  <td>
                    {editMode ? (
                      <textarea
                        value={problem.Target}
                        onChange={e => {
                          const updatedProblems = [...problemsByYear[year]];
                          updatedProblems[index].Target = e.target.value;
                          setProblemsByYear({
                            ...problemsByYear,
                            [year]: updatedProblems
                          });
                        }}
                        style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                        placeholder={problem.Target}
                      />
                    ) : (
                      problem.Target
                    )}
                  </td>
                  <td>
                    {editMode ? (
                      <input
                        type="datetime-local"
                        value={problem.FolDate}
                        onChange={e => {
                          const updatedProblems = [...problemsByYear[year]];
                          updatedProblems[index].FolDate = e.target.value;
                          setProblemsByYear({
                            ...problemsByYear,
                            [year]: updatedProblems
                          });
                        }}
                        className="custominput"
                        placeholder="Format : YYYY-MM-DDTHH:MM:SS+07:00"
                      />
                    ) : (
                      <span>{problem.FolDate}</span>
                    )}

                  </td>
                  <td>
                    {editMode ? (
                      <textarea
                        value={problem.Status}
                        onChange={e => {
                          const updatedProblems = [...problemsByYear[year]];
                          updatedProblems[index].Status = e.target.value;
                          setProblemsByYear({
                            ...problemsByYear,
                            [year]: updatedProblems
                          });
                        }}
                        style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                        placeholder={problem.Status}
                      />
                    ) : (
                      problem.Status
                    )}
                  </td>
                </tr>
              ))}
              {(newRows[year] || []).map((newRow, index) => (
                <tr key={`${year}_new_${index}`}>
                  <td>
                    <textarea
                      value={newRow.Masalah || ""}
                      onChange={e => {
                        const updatedNewRows = { ...newRows };
                        updatedNewRows[year][index].Masalah = e.target.value;
                        setNewRows(updatedNewRows);
                      }}
                      style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                      placeholder="Masalah"
                    />
                    <div>
                    <div className="delete">
                <button onClick={() => handleDeleteNewRowClick(year, index)}>Delete</button>
                </div>
                </div>

                  </td>
                  <td>
                    <textarea
                      value={newRow.Why[0] || ""}
                      onChange={e => {
                        const updatedNewRows = { ...newRows };
                        updatedNewRows[year][index].Why[0] = e.target.value;
                        setNewRows(updatedNewRows);
                      }}
                      style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                      placeholder="Why 1"
                    />
                  </td>
                  <td>
                    <textarea
                      value={newRow.Why[1] || ""}
                      onChange={e => {
                        const updatedNewRows = { ...newRows };
                        updatedNewRows[year][index].Why[1] = e.target.value;
                        setNewRows(updatedNewRows);
                      }}
                      style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                      placeholder="Why 2"
                    />
                  </td>
                  <td>
                    <textarea
                      value={newRow.Why[2] || ""}
                      onChange={e => {
                        const updatedNewRows = { ...newRows };
                        updatedNewRows[year][index].Why[2] = e.target.value;
                        setNewRows(updatedNewRows);
                      }}
                      style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                      placeholder="Why 3"
                    />
                  </td>
                  <td>
                    <textarea
                      value={newRow.Why[3] || ""}
                      onChange={e => {
                        const updatedNewRows = { ...newRows };
                        updatedNewRows[year][index].Why[3] = e.target.value;
                        setNewRows(updatedNewRows);
                      }}
                      style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                      placeholder="Why 4"
                    />
                  </td>
                  <td>
                    <textarea
                      value={newRow.Why[4] || ""}
                      onChange={e => {
                        const updatedNewRows = { ...newRows };
                        updatedNewRows[year][index].Why[4] = e.target.value;
                        setNewRows(updatedNewRows);
                      }}
                      style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                      placeholder="Why 5"
                    />
                  </td>
                  <td>
                    <textarea
                      value={newRow.Tindakan || ""}
                      onChange={e => {
                        const updatedNewRows = { ...newRows };
                        updatedNewRows[year][index].Tindakan = e.target.value;
                        setNewRows(updatedNewRows);
                      }}
                      style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                      placeholder="Tindakan"
                    />
                  </td>
                  <td>
                    <textarea
                      value={newRow.Pic || ""}
                      onChange={e => {
                        const updatedNewRows = { ...newRows };
                        updatedNewRows[year][index].Pic = e.target.value;
                        setNewRows(updatedNewRows);
                      }}
                      style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                      placeholder="PIC"
                    />
                  </td>
                  <td>
                    <textarea
                      value={newRow.Target || ""}
                      onChange={e => {
                        const updatedNewRows = { ...newRows };
                        updatedNewRows[year][index].Target = e.target.value;
                        setNewRows(updatedNewRows);
                      }}
                      style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                      placeholder="Target"
                    />
                  </td>
                  <td>
                    <input
                      type="datetime-local"
                      value={newRow.FolDate || ""}
                      onChange={e => {
                        const updatedNewRows = { ...newRows };
                        updatedNewRows[year][index].FolDate = e.target.value;
                        setNewRows(updatedNewRows);
                      }}
 
                      placeholder="Date"
                    />
                  </td>
                  <td>
                    <textarea
                      value={newRow.Status || ""}
                      onChange={e => {
                        const updatedNewRows = { ...newRows };
                        updatedNewRows[year][index].Status = e.target.value;
                        setNewRows(updatedNewRows);
                      }}
                      style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                      placeholder="Status"
                    />
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
           <div style={{display:"flex"}}>
                <div style={{marginRight:"20px"}} className="compare">
              {editMode && (
                            <button onClick={() => handleDeleteAllData(year)}>Delete All Data for {year}</button>

                )}
            </div>      
          </div>
            </div>
       ))}
    </div>
  );
};

export default EditUploadTableAnalysis;

=========================================


import React, { useState, useEffect } from 'react';
import "../Styles/saved-table.css";
import * as XLSX from 'xlsx';


const SavedSafetyTable = () => {
  const [items, setItems] = useState([]);
  const [selectedItem, setSelectedItem] = useState('');
  const [filteredItems, setFilteredItems] = useState([]);
  const [selectedYears, setSelectedYears] = useState([]);
  const [availableYears, setAvailableYears] = useState([]);
  const [dropdownOpen, setDropdownOpen] = useState(false);
  const [searchName, setSearchName] = useState('');
  const [isEditing, setIsEditing] = useState(false);
  const [editedData, setEditedData] = useState({});
  const [lastRowId, setLastRowId] = useState(0);
  const [isEditingRows, setIsEditingRows] = useState([]);
  const [editingTableIndex, setEditingTableIndex] = useState(null); // State baru untuk menyimpan indeks tabel yang sedang dalam mode pengeditan
  const [file, setFile] = useState(null); // State untuk menyimpan file yang diupload
  const [selectedFile, setSelectedFile] = useState(null);
  const [fileData, setFileData] = useState(null);
  const [isLoading, setIsLoading] = useState(false); // State for loading message


  // Fungsi untuk menambahkan faktor baru
const handleNewFactor = (resultIndex, year) => {
  const newFactor = {
  Factor_ID: null, // or generate an id if necessary
  Title: "",
  Unit: "",
  Target: "",
  Planned: {
  Monthly: [{ January: 0, February: 0, March: 0, April: 0, May: 0, June: 0, July: 0, August: 0, September: 0, October: 0, November: 0, December: 0 }]
  },
  Actual: {
  Monthly: [{ January: 0, February: 0, March: 0, April: 0, May: 0, June: 0, July: 0, August: 0, September: 0, October: 0, November: 0, December: 0 }]
  }
  };
  
  // Menambahkan faktor baru ke data yang sedang diedit
  setEditedData(prevData => {
  const newData = JSON.parse(JSON.stringify(prevData)); // Deep clone to avoid direct state mutation
  if (newData.Year === year) {
  newData.Results[resultIndex].Factors.push(newFactor); // Add new factor to the specific result
  }
  return newData;
  });
  
  // Update the filteredItems to show the new factor in the UI immediately
  setFilteredItems(prevFilteredItems => {
  return prevFilteredItems.map(item => {
  if (item.Year === year) {
  const updatedResults = item.Results.map((result, idx) => {
  if (idx === resultIndex) {
  return {
  ...result,
  Factors: [...result.Factors, newFactor]
  };
  }
  return result;
  });
  return {
  ...item,
  Results: updatedResults
  };
  }
  return item;
  });
  });
  };

  // This function handles file selection
  const handleFileChange = (event) => {
    const file = event.target.files[0];
    console.log('File selected:', file); // Log the selected file
    setSelectedFile(file); // Set the selected file to the state

    // Read the file data for preview purposes (optional)
    if (file) {
      const reader = new FileReader();
      reader.onload = (event) => {
        const workbook = XLSX.read(event.target.result, { type: 'binary' });
        const sheetName = workbook.SheetNames[0];
        const sheet = workbook.Sheets[sheetName];
        const data = XLSX.utils.sheet_to_json(sheet);
        setFileData(data); // Store parsed data for preview
      };
      reader.readAsBinaryString(file);
    }
  };

  // This function handles file upload
  const handleFileUpload = async () => {
    if (selectedFile) { // Check if a file is selected
      try {
        console.log('Preparing to upload file:', selectedFile); // Log before uploading

        const formData = new FormData();
        formData.append('file', selectedFile); // Append the actual file to FormData

        const response = await fetch('http://localhost:8080/kpi/file/kpi', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('authToken')}`,
            // 'Content-Type' is not needed; 'fetch' sets it automatically when FormData is used.
          },
          body: formData // Send the FormData containing the file
        });

        if (response.ok) {
          console.log('File uploaded successfully'); // Log success
          alert('File berhasil diunggah dan data diproses');
          // Handle further actions if necessary
        } else {
          const errorText = await response.text();
          console.error('Failed to upload file:', errorText); // Log the error message
          alert(`Gagal mengunggah file: ${errorText}`);
        }
      } catch (error) {
        console.error('Error uploading file:', error); // Log the error
        alert('Error uploading file: ' + error.message);
      }
    } else {
      alert('Harap pilih file terlebih dahulu');
    }
  };

  useEffect(() => {
    // Initialize isEditingRows state based on the number of items
    setIsEditingRows(new Array(items.length).fill(false));
  }, [items]);

  const handleSaveData = async (item_id) => {
    setIsLoading(true); // Set loading to true
    const authToken = localStorage.getItem('authToken');
  
    try {
      const formattedData = {
        Item_ID: item_id,
        Name: editedData.Name,
        Results: editedData.Results.map(result => ({
          Name: result.Name,
          Result_ID: result.Result_ID,
          Factors: result.Factors.map(factor => ({
            Factor_ID: factor.Factor_ID,
            Title: factor.Title,
            Unit: factor.Unit,
            Target: factor.Target,
            Planned: factor.Planned,
            Actual: factor.Actual
          }))
        })),
        Year: editedData.Year
      };
  
      const isNewData = !items.some(item => item.Item_ID === item_id);
      const method = isNewData ? 'POST' : 'PUT';
      const url = isNewData
        ? `http://localhost:8080/kpi/item`
        : `http://localhost:8080/kpi/item/entire/${item_id}`;
  
      const response = await fetch(url, {
        method,
        headers: {
          'Content-Type': 'application/json',
          "Authorization": `Bearer ${authToken}`
        },
        body: JSON.stringify(formattedData)
      });
  
      if (response.ok) {
        setIsLoading(false); // Set loading to false
        alert('Data updated successfully');
        setIsEditing(false);
        const updatedItems = isNewData
          ? [...items, formattedData]
          : items.map(item => item.Item_ID === item_id ? formattedData : item);
        setItems(updatedItems);
      } else {
        const errorText = await response.text();
        setIsLoading(false); // Set loading to false
        console.error('Failed to update data:', errorText);
        alert(`Failed to update data: ${errorText}`);
      }
  
    } catch (error) {
      setIsLoading(false); // Set loading to false
      console.error('Error updating data:', error);
    }
  };

  const handleAddRowClick = (year) => {
    const newRowId = lastRowId + 1;
    setLastRowId(newRowId);
  
    // Membuat baris baru dengan data default
    const newRow = {
      Result_ID: newRowId,
      Name: "",
      Factors: [
        {
          Title: "",
          Unit: "",
          Target: "",
          Planned: {
            Monthly: [{ January: 0, February: 0, March: 0, April: 0, May: 0, June: 0, July: 0, August: 0, September: 0, October: 0, November: 0, December: 0 }]
          },
          Actual: {
            Monthly: [{ January: 0, February: 0, March: 0, April: 0, May: 0, June: 0, July: 0, August: 0, September: 0, October: 0, November: 0, December: 0 }]
          }
        }
      ],
      Year: year
    };
  
    // Menambahkan baris baru ke data yang sedang diedit, hanya jika tahunnya cocok
    setEditedData(prevData => {
      // Mengecek apakah tahun pada data yang sedang diedit sama dengan tahun yang dipilih
      if (prevData.Year === year) {
        return {
          ...prevData,
          Results: [...prevData.Results, newRow]
        };
      } else {
        // Jika tahunnya tidak cocok, tidak ada perubahan yang dibuat
        return prevData;
      }
    });
  
    // Juga tambahkan baris baru ke filteredItems
    setFilteredItems(prevFilteredItems => {
      return prevFilteredItems.map(item => {
        if (item.Year === year) {
          return {
            ...item,
            Results: [...item.Results, newRow]
          };
        }
        return item;
      });
    });
  };

  const handleChange = (e, resultIndex, factorIndex, type, month) => {
    const { value } = e.target;
    const numericValue = parseFloat(value);
  
    if (!isNaN(numericValue)) {
      setEditedData(prevData => {
        const newData = JSON.parse(JSON.stringify(prevData));
        if (!newData.Results[resultIndex].Factors[factorIndex][type]) {
          newData.Results[resultIndex].Factors[factorIndex][type] = { Monthly: [{}] };
        } else if (!newData.Results[resultIndex].Factors[factorIndex][type].Monthly) {
          newData.Results[resultIndex].Factors[factorIndex][type].Monthly = [{}];
        }
        newData.Results[resultIndex].Factors[factorIndex][type].Monthly[0][month] = numericValue;
        return newData;
      });
    }
  };
  
  const handleNameChange = (e) => {
    setSearchName(e.target.value);
  };

  useEffect(() => {
    var responseClone;
  
    fetch('http://localhost:8080/kpi/item')
      .then(function(response) {
        responseClone = response.clone();
        return response.json();
      })
      .then(function(data) {
        console.log('Response JSON (item):', data);
  
        if (data) {
          setItems(data.data);
          if (data.data.length > 0) {
            setSelectedItem(data.data[0].Name);
            const years = Array.from(new Set(data.data.map(item => item.Year)));
            setAvailableYears(years);
          }
        } else {
          console.error('Empty data received');
        }
      })
      .catch(function(error) {
        console.error('Error fetching item data:', error);
        responseClone.text().then(function(bodyText) {
          console.log('Received the following instead of valid JSON:', bodyText);
        });
      });
  }, []);
  

  useEffect(() => {
    const filtered = items.filter(item =>
      item.Name === selectedItem &&
      (isEditing ? item.Year === editedData.Year : selectedYears.length === 0 || selectedYears.includes(item.Year)) &&
      (item.Results.some(result => result.Name.toLowerCase().includes(searchName.toLowerCase())))
    );
    setFilteredItems(filtered);
  }, [selectedItem, selectedYears, items, searchName, isEditing, editedData.Year]);
  

  // Fungsi untuk menentukan apakah tahun tertentu terpilih atau tidak
  const isYearSelected = (year) => {
    return selectedYears.includes(year);
  };

  const handleYearChange = (year) => {
    setSelectedYears(prevSelectedYears =>
      prevSelectedYears.includes(year)
        ? prevSelectedYears.filter(y => y !== year)
        : [...prevSelectedYears, year]
    );
  };

  const handleResetFilters = () => {
    setSelectedYears([]);
    setSearchName('');
  };

  const toggleDropdown = () => {
    setDropdownOpen(!dropdownOpen);
  };

  const handleUpdateData = (itemIndex) => {
    // Cek apakah ada tabel lain yang sedang dalam mode pengeditan
    const isAnyTableEditing = isEditingRows.some((editingStatus, index) => editingStatus && index !== itemIndex);
  
    // Jika ada tabel lain yang sedang dalam mode pengeditan, munculkan prompt
    if (isAnyTableEditing) {
      alert("Anda hanya bisa mengedit 1 tabel!");
    } else {
      // Set isEditing status for the clicked row
      setIsEditingRows(prevIsEditingRows => {
        const updatedIsEditingRows = [...prevIsEditingRows];
        updatedIsEditingRows[itemIndex] = true;
        return updatedIsEditingRows;
      });
  
      // Set edited data for the clicked row
      const dataToEdit = filteredItems[itemIndex];
      console.log('Data to be updated:', dataToEdit);
      if (dataToEdit) {
        setEditedData({ ...dataToEdit });
        setEditingTableIndex(itemIndex); // Set indeks tabel yang sedang dalam mode pengeditan
      } else {
        console.error('No data available for the selected item');
      }
    }
  };
  

  
// Dalam komponen SavedSafetyTable
const handleDeleteRowClick = async (item_id) => {
  const userConfirmed = window.confirm("Apakah anda yakin ingin menghapus row ini?");
  if (!userConfirmed) {
    return; // Exit the function if the user cancels the deletion
  }
  const authToken = localStorage.getItem('authToken');

  try {
    const response = await fetch(`http://localhost:8080/kpi/item/entire/${item_id}`, {
      method: 'DELETE',
      headers: {
        'Content-Type': 'application/json',
        "Authorization": `Bearer ${authToken}`
      }
    });

    if (response.ok) {
      alert('Row deleted successfully');
      // Hapus baris dari state filteredItems
      setFilteredItems(prevFilteredItems => prevFilteredItems.filter(item => item.Item_ID !== item_id));
      // Hapus baris dari state items
      setItems(prevItems => prevItems.filter(item => item.Item_ID !== item_id));
    } else {
      const errorText = await response.text();
      console.error('Failed to delete row:', errorText);
      alert(`Failed to delete row: ${errorText}`);
    }
  } catch (error) {
    console.error('Error deleting row:', error);
  }
};

const handleDeletePerResult = async (result_id) => {
  const userConfirmed = window.confirm("Apakah anda yakin ingin menghapus result ini? Seluruh factor yang terhubung dengan result ini juga akan terhapus!");
  if (!userConfirmed) {
    return; // Exit the function if the user cancels the deletion
  }
  const authToken = localStorage.getItem('authToken');

  try {
    const response = await fetch(`http://localhost:8080/kpi/result/entire/${result_id}`, {
      method: 'DELETE',
      headers: {
        'Content-Type': 'application/json',
        "Authorization": `Bearer ${authToken}`
      }
    });

    if (response.ok) {
      alert('Result deleted successfully');
      setFilteredItems(prevFilteredItems => {
        return prevFilteredItems.map(item => ({
          ...item,
          Results: item.Results.filter(result => result.Result_ID !== result_id)
        }));
      });
      setItems(prevItems => {
        return prevItems.map(item => ({
          ...item,
          Results: item.Results.filter(result => result.Result_ID !== result_id)
        }));
      });
    } else {
      const errorText = await response.text();
      console.error('Failed to delete result:', errorText);
      alert(`Failed to delete result: ${errorText}`);
    }
  } catch (error) {
    console.error('Error deleting result:', error);
  }
};

const handleDeletePerFactor = async (factor_id) => {
  const userConfirmed = window.confirm("Apakah anda yakin ingin menghapus seluruh data pada tahun ini?");
  if (!userConfirmed) {
    return; // Exit the function if the user cancels the deletion
  }
  const authToken = localStorage.getItem('authToken');

  try {
    const response = await fetch(`http://localhost:8080/kpi/factor/entire/${factor_id}`, {
      method: 'DELETE',
      headers: {
        'Content-Type': 'application/json',
        "Authorization": `Bearer ${authToken}`
      }
    });

    if (response.ok) {
      alert('Factor deleted successfully');
      setFilteredItems(prevFilteredItems => {
        return prevFilteredItems.map(item => ({
          ...item,
          Results: item.Results.map(result => ({
            ...result,
            Factors: result.Factors?.filter(factor => factor.Factor_ID !== factor_id) || []
          }))
        }));
      });
      setItems(prevItems => {
        return prevItems.map(item => ({
          ...item,
          Results: item.Results.map(result => ({
            ...result,
            Factors: result.Factors?.filter(factor => factor.Factor_ID !== factor_id) || []
          }))
        }));
      });
    } else {
      const errorText = await response.text();
      console.error('Failed to delete factor:', errorText);
      alert(`Failed to delete factor: ${errorText}`);
    }
  } catch (error) {
    console.error('Error deleting factor:', error);
  }
};

  

  return (
    <div className="table-container">
      <div style={{marginBottom:"10px"}}  className="filter-container">
        <label htmlFor="item-select"></label>
        <select
          id="item-select"
          value={selectedItem}
          onChange={(e) => setSelectedItem(e.target.value)}
        >
          <option value="S">Safety</option>
          <option value="E">Environment</option>
          <option value="Q">Quality</option>
          <option value="C">Cost</option>
          <option value="D">Delivery</option>
        </select>

        <div className="dropdown">
          <button onClick={toggleDropdown} className="dropdown-button">
            Pilih Tahun
          </button>
          {dropdownOpen && (
            <div className="dropdown-content">
              {availableYears.map((year, index) => (
                <label key={index} className="dropdown-item">
                  <input
                    type="checkbox"
                    value={year}
                    checked={selectedYears.includes(year)}
                    onChange={() => handleYearChange(year)}
                  />
                  {year}
                </label>
              ))}
            </div>
          )}
        </div>
        <button onClick={handleResetFilters} className="dropdown-button" style={{marginRight:"800px"}}> Hapus Semua Filter </button>
       

         
      </div>

           <input s
            type="text"
            placeholder="Filter Result..."
            value={searchName}
            onChange={handleNameChange}
            style={{ width: 'calc(100% - 14px)', marginBottom:"10px" }}
          />
 
       <div className='inputfile' style={{ display: 'flex', alignItems: 'center', marginBottom: '10px' }}>
      <input type="file" onChange={handleFileChange} style={{ marginRight: '10px', padding: '5px 10px', borderRadius: '5px'}} />
      <button onClick={handleFileUpload} style={{ padding: '5px 10px', borderRadius: '5px', backgroundImage: 'linear-gradient(to right, rgb(26, 171, 0), rgb(12, 217, 29))', color: 'white', border: 'none' }}>Upload Data</button>
 
</div>
      {filteredItems.length > 0 ? (
        filteredItems.map((item, itemIndex) => (
          <div key={itemIndex}>
            {item.Results.length > 0 ? (
              <table key={`${itemIndex}-${item.Year}`} className="saved-safety-table">
                <caption>{`Tahun ${item.Year}`}</caption>
                <thead>
                  <tr>
                    <th rowSpan="2">KPI Result</th>
                    <th colSpan="1">KPI Factor</th>
                    <th colSpan="2" rowSpan="2">Status</th>
                    <th rowSpan="3">Unit</th>
                    <th rowSpan="3">Target</th>
                    <th colSpan="12">Bulan</th>
                   </tr>
                  <tr>
                    <th>KPI Factor Name</th>
                    <th>Jan</th>
                    <th>Feb</th>
                    <th>Mar</th>
                    <th>Apr</th>
                    <th>May</th>
                    <th>Jun</th>
                    <th>Jul</th>
                    <th>Aug</th>
                    <th>Sep</th>
                    <th>Oct</th>
                    <th>Nov</th>
                    <th>Dec</th>
              </tr>
            </thead>
            <tbody>
              {item.Results.map((result, resultIndex) => (
                result.Factors.length > 0 ? (
                  result.Factors.map((factor, factorIndex) => (
                    <React.Fragment key={`${itemIndex}-${resultIndex}-${factorIndex}`}>
                      {/* Render baris dengan kolom Name, Title, Unit, Target */}
                      <tr>
                      <td rowSpan={2}>
                        <div style={{display:"inline-block"}} className='delete'>
                        {isEditingRows[itemIndex] ? (
                    <>
                      <textarea
                        value={editedData.Results[resultIndex].Name}
                        onChange={(e) => {
                          const updatedData = { ...editedData };
                          updatedData.Results[resultIndex].Name = e.target.value;
                          setEditedData(updatedData);
                        }}
                        style={{ width: '100px', height: '50px' }}
                      />
                      <div>
                        <button style={{marginBottom:"5px", marginRight:"5px"}} onClick={() => handleDeletePerResult(result.Result_ID)}>Delete Result</button>
                        <button onClick={() => handleDeletePerFactor(factor.Factor_ID)}>Delete Factor</button>
                      </div>

                      <div className='savechanges'>
                        <button
                          onClick={() => handleNewFactor(resultIndex, item.Year)}
                          style={{ width: '100%' }}
                        >
                          Add New Factor
                        </button>
                      </div>
                    </>
                  ) : (
                    <>{result.Name}</>
                  )}
                      </div>
                    </td>

                        <td rowSpan={2}>
                        {isEditingRows[itemIndex] ? (
                            <textarea
                              value={editedData.Results[resultIndex].Factors[factorIndex].Title}
                              onChange={(e) => {
                                const updatedData = { ...editedData };
                                updatedData.Results[resultIndex].Factors[factorIndex].Title = e.target.value;
                                setEditedData(updatedData);
                              }}
                              style={{ width: '100px', height: '50px' }} // Anda dapat menyesuaikan nilai width dan height sesuai kebutuhan

                            />
                          ) : (
                            factor.Title
                          )}
                        </td>
                        <td colSpan={2}>Plan</td>
                        <td rowSpan={2}>
                        {isEditingRows[itemIndex] ? (
                            <textarea
                              value={editedData.Results[resultIndex].Factors[factorIndex].Unit}
                              onChange={(e) => {
                                const updatedData = { ...editedData };
                                updatedData.Results[resultIndex].Factors[factorIndex].Unit = e.target.value;
                                setEditedData(updatedData);
                              }}
                              style={{ width: '100px', height: '50px' }} // Anda dapat menyesuaikan nilai width dan height sesuai kebutuhan

                            />
                          ) : (
                            factor.Unit
                          )}
                        </td>
                        <td rowSpan={2}>
                        {isEditingRows[itemIndex] ? (
                            <textarea
                              value={editedData.Results[resultIndex].Factors[factorIndex].Target}
                              onChange={(e) => {
                                const updatedData = { ...editedData };
                                updatedData.Results[resultIndex].Factors[factorIndex].Target = e.target.value;
                                setEditedData(updatedData);
                              }}
                              style={{ width: '100px', height: '50px' }} // Anda dapat menyesuaikan nilai width dan height sesuai kebutuhan

                            />
                          ) : (
                            factor.Target
                          )}
                        </td>
                        {/* Render kolom bulan untuk Planned */}
                        {['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'].map((month, monthIndex) => (
                          <td key={monthIndex}>
  {isEditingRows[itemIndex] ? (
                              <input
                                type="number"
                                value={(editedData.Results[resultIndex].Factors[factorIndex]['Planned']?.Monthly[0]?.[month]) || ''}
                                onChange={(e) => handleChange(e, resultIndex, factorIndex, 'Planned', month)}
                              />
                            ) : (
                              (factor['Planned'] && factor['Planned'].Monthly[0][month]) || 0
                            )}
                          </td>
                        ))}
               
                      </tr>
                      {/* Render baris untuk Actual */}
                      <tr>
                        <td colSpan={2}>Actual</td>
                        {/* Render kolom bulan untuk Actual */}
                        {['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'].map((month, monthIndex) => (
                          <td key={monthIndex}>
  {isEditingRows[itemIndex] ? (
                              <input
                                type="number"
                                value={(editedData.Results[resultIndex].Factors[factorIndex]['Actual']?.Monthly[0]?.[month]) || ''}
                                onChange={(e) => handleChange(e, resultIndex, factorIndex, 'Actual', month)}
                              />
                            ) : (
                              (factor['Actual'] && factor['Actual'].Monthly[0][month]) || 0
                            )}
                          </td>
                        ))}
                      </tr>
                    </React.Fragment>
                  ))
                ) : (
                  <tr key={`${itemIndex}-${resultIndex}-no-factors`}>
                    <td colSpan="18">Data factors telah dihapus</td>
                  </tr>
                )
              ))}

            </tbody>

            <div className="buttonsum" style={{ display: 'flex' }}>
   {isEditingRows[itemIndex] ? (
      <>
      <div className='delete'>
        <button
          onClick={() => handleDeleteRowClick(item.Item_ID)}
          style={{
            marginRight: '5px',
             color: 'white',
            display: 'inline-block',
            marginBottom: '5px',
            padding: '5px 10px',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer',
            padding: '10px 20px'
,
            marginTop: '10px'

          }}
        >
          Delete All Data
        </button>
        </div>
        <div className='savechanges'>

        <button
          onClick={() => handleAddRowClick(item.Year)}
          style={{
              color: 'white',
            marginTop:"10px",
            width:"100%",
            display: 'inline-block',
            marginRight:'10px',
            padding: '5px 10px',
            border: 'none',
            borderRadius: '5px',
            padding: '10px 20px',
            cursor: 'pointer',
            marginBottom: '10px'
          }}
        >
          Add New Result
        </button>
        </div>
        <div className='savechanges'>
        <button
        onClick={() => handleSaveData(item.Item_ID)}
        style={{
          marginRight: '5px',
          color: 'white',
          marginTop:"10px",
          marginBottom: '5px',
          padding: '5px 10px',
          border: 'none',
          borderRadius: '5px',
          padding: '10px 20px',
          marginLeft:"5px"
,
    cursor: 'pointer'
  }}
>
  Save Table Data
</button>
</div>

        {/* <div className='savechanges'>
        <button
          onClick={() => handleNewFactor(itemIndex, item.Year)}
          style={{
            marginRight: '5px',
            color: 'white',
            marginTop: "10px",
            width: "100%",
            display: 'inline-block',
            padding: '5px 10px',
            border: 'none',
            borderRadius: '5px',
            padding: '10px 20px',
            cursor: 'pointer',
            marginBottom: '10px'
          }}
        >
          Add New Factor
        </button>
      </div> */}
      </>
    ) : (
      <>
        <button
  onClick={() => handleUpdateData(itemIndex)}
  style={{
    marginRight: '5px',
    background: 'linear-gradient(to right, #1aab00, #0cd91d)',
    color: 'white',
    display: 'inline-block',
    marginBottom: '10px',
    padding: '5px 10px',
    border: 'none',
    borderRadius: '5px',
    cursor: 'pointer',
    marginTop: '10px',
    padding: '10px 20px'
  }}
>
  Update Data
</button>

      </>
    )}
  </div>
  {isLoading && <div style={{marginBottom:"15px"}}>Mohon menunggu... Tolong untuk TIDAK melakukan tindakan apapun pada proses penyimpanan data!</div>}

          </table>
          
        ) : (
          <p key={`${itemIndex}-no-results`}>Data results tidak tersedia</p>
        )}
      </div>
    ))
  ) : (
    <p>Data items tidak tersedia</p>
  )}
</div>
);
};

export default SavedSafetyTable;

==================================

import React, { useState, useEffect } from 'react';
import { Bar, Line } from 'react-chartjs-2';
import { Chart } from 'chart.js/auto';
import '../Styles/chart.css';
import ChartDataLabels from 'chartjs-plugin-datalabels';
import { registerables } from 'chart.js';

function ChartComponent({ chartSize }) {
  const [chartData, setChartData] = useState([]);
  const [filteredChartData, setFilteredChartData] = useState([]);
  const [searchTerm, setSearchTerm] = useState('');
  const [activeSearchTerm, setActiveSearchTerm] = useState('');
  const [selectedItem, setSelectedItem] = useState('S'); // State untuk item yang dipilih
  const [selectedYears, setSelectedYears] = useState([]); // State untuk tahun yang dipilih
  const [availableYears, setAvailableYears] = useState([]); // State untuk menyimpan tahun yang tersedia
  const [dropdownOpen, setDropdownOpen] = useState(false); // State untuk dropdown

  Chart.register(...registerables, ChartDataLabels);

  const handleSearchChange = (event) => {
    setSearchTerm(event.target.value);
  };

  const handleSearch = () => {
    setActiveSearchTerm(searchTerm);
  };

  const handleRemoveFilter = () => {
    setSearchTerm('');
    setActiveSearchTerm('');
  };

  const handleItemChange = (event) => {
    setSelectedItem(event.target.value);
  };

  const toggleDropdown = () => {
    setDropdownOpen(!dropdownOpen);
  };

  const handleYearChange = (year) => {
    setSelectedYears((prevSelectedYears) =>
      prevSelectedYears.includes(year)
        ? prevSelectedYears.filter((y) => y !== year)
        : [...prevSelectedYears, year]
    );
  };

  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch('http://localhost:8080/kpi/item');
        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }
        const data = await response.json();
        console.log('Response JSON (item):', data);

        const formattedChartData = [];
        const years = new Set();

        data.data.forEach(item => {
          years.add(item.Year); // Menambahkan tahun ke set tahun
          if (item.Name === selectedItem) { // Filter berdasarkan item yang dipilih
            item.Results.forEach(result => {
              result.Factors.forEach(factor => {
                const plannedMonthly = factor.Planned?.Monthly[0] || {};
                const actualMonthly = factor.Actual?.Monthly[0] || {};
        
                formattedChartData.push({
                  kpiResult: result.Name,
                  kpiFactorName: factor.Title,
                  unit: factor.Unit,
                  target: factor.Target,
                  planned: {
                    January: plannedMonthly.January,
                    February: plannedMonthly.February,
                    March: plannedMonthly.March,
                    April: plannedMonthly.April,
                    May: plannedMonthly.May,
                    June: plannedMonthly.June,
                    July: plannedMonthly.July,
                    August: plannedMonthly.August,
                    September: plannedMonthly.September,
                    October: plannedMonthly.October,
                    November: plannedMonthly.November,
                    December: plannedMonthly.December,
                  },
                  actual: {
                    January: actualMonthly.January,
                    February: actualMonthly.February,
                    March: actualMonthly.March,
                    April: actualMonthly.April,
                    May: actualMonthly.May,
                    June: actualMonthly.June,
                    July: actualMonthly.July,
                    August: actualMonthly.August,
                    September: actualMonthly.September,
                    October: actualMonthly.October,
                    November: actualMonthly.November,
                    December: actualMonthly.December,
                  },
                  year: item.Year // Tambahkan informasi tahun
                });
              });
            });
          }
        });

        setAvailableYears(Array.from(years)); // Set tahun yang tersedia
        setChartData(formattedChartData);
        setFilteredChartData(formattedChartData);
      } catch (error) {
        console.error('Error fetching data', error);
      }
    };

    fetchData();
  }, [selectedItem]); // Menambahkan selectedItem sebagai dependency agar fetch ulang saat item berubah

  useEffect(() => {
    let filteredData = chartData;
    if (activeSearchTerm !== '') {
      filteredData = filteredData.filter(data =>
        data.kpiResult.toLowerCase().includes(activeSearchTerm.toLowerCase()) ||
        data.kpiFactorName.toLowerCase().includes(activeSearchTerm.toLowerCase())
      );
    }
    if (selectedYears.length > 0) {
      filteredData = filteredData.filter(data => selectedYears.includes(data.year));
    }
    setFilteredChartData(filteredData);
  }, [activeSearchTerm, selectedYears, chartData]);

  const chartOptions = {
    plugins: {
      title: {
        display: true,
        text: `Tabel Data Tahun ${selectedYears.join(', ')}`, // Menampilkan tahun yang dipilih
        padding: {
          top: 0,
          bottom: 5
        },
        font: {
          size: 18,
          weight: 'bold'
        }
      },
      datalabels: {
        display: true,
        formatter: function (value) {
          return value;
        },
        color: 'white' // Mengatur warna angka menjadi putih
      }
    },
    scales: {
      x: {
        type: 'category',
      },
      y: {
        beginAtZero: false, // Mulai dari 0
        min:0.0, // Nilai minimum
        barPercentage: 0.8,
        categoryPercentage: 0.9,
      },
    },
  };

  const gradientColor = (context, isExceedTarget = true) => {
    const gradient = context.chart.ctx.createLinearGradient(0, 0, 0, 300);
    if (isExceedTarget) {
      gradient.addColorStop(0, '#FF0000'); // Warna merah
      gradient.addColorStop(1, '#8b0000'); // Warna merah tua
    } else {
      gradient.addColorStop(0, '#00FF00'); // Warna hijau
      gradient.addColorStop(1, '#FFFF00'); // Warna kuning
    }
    return gradient;
  };

  return (
    <div className='chart'>
      <div style={{ textAlign: 'left', marginBottom: '0px', marginTop: '60px', marginLeft: '140px', marginBottom:"50px" }}>
         <div style={{marginTop:"0px", width:"calc(100% - 18px)", marginLeft:"1px", marginBottom:"10px" }} className="filter-containers">
          
        <select 
          id="item-select"

          onChange={handleItemChange} value={selectedItem}>
          <option value="S">Safety</option>
          <option value="E">Environment</option>
          <option value="Q">Quality</option>
          <option value="C">Cost</option>
          <option value="D">Delivery</option>
        </select>

        <div className="dropdown">
          <button onClick={toggleDropdown} className="dropdown-button">
            Pilih Tahun
          </button>
          {dropdownOpen && (
            <div className="dropdown-content">
              {availableYears.map((year, index) => (
                <label key={index} className="dropdown-item">
                  <input
                    type="checkbox"
                    value={year}
                    checked={selectedYears.includes(year)}
                    onChange={() => handleYearChange(year)}
                  />
                  {year}
                </label>
              ))}
            </div>
          )}
        </div>
        </div>
        <input type="text" placeholder="Search KPI Result or Factor..." onChange={handleSearchChange} />
        <div className='search'>
          <button onClick={handleSearch}>Search</button>
          <button onClick={handleRemoveFilter} style={{ marginLeft: '7px' }}>Remove Filter</button>
        </div>
        <div style={{ display: 'flex', justifyContent: 'center', gap: '10px', flexWrap: 'wrap' }}>
          {filteredChartData.length === 0 ? (
            <p style={{ backgroundColor: '#8b0000', borderRadius: '5px', color: 'white', padding: '10px' }}>Data not available for this item!</p>
          ) : (
            filteredChartData.map((data, index) => (
              <ChartContainer
                key={index}
                data={data}
                options={{ ...chartOptions, plugins: { ...chartOptions.plugins, title: { ...chartOptions.plugins.title, text: `Tabel Data Tahun ${data.year}` } } }} // Set judul chart sesuai dengan tahun
                size={chartSize}
                gradientColor={gradientColor}
              />
            ))
          )}
        </div>
      </div>
    </div>
  );
}



const ChartContainer = ({ data, options, size, gradientColor }) => {
  const { kpiResult, kpiFactorName, unit, target, planned, actual, year } = data;

  // Prepare chart data
  const chartData = {
    labels: Object.keys(planned),
    datasets: [
      {
        label: 'Planned',
        data: Object.values(planned),
        borderColor: gradientColor,
        backgroundColor: Object.keys(planned).map((month, index) => {
          const plannedValue = planned[month];
          const actualValue = actual[month];
          return plannedValue >= actualValue ? '#a60b0b' : '#1FC216'; // Green if planned >= actual, red otherwise
        }),        
        fill: false,
        type: 'line',
        borderWidth: 2, // Lebar batas target
        type: 'line', // Jenis chart (line)
        fill: false, // Tidak diisi dengan warna
        pointStyle: 'circle', // Gaya marker titik
        pointRadius: 5, // Ukuran marker titik
        pointHoverRadius: 8, // Ukuran marker titik saat dihover
        datalabels: {
          display: true, // Selalu tampilkan datalabels untuk dataset ini
          color: '#a60b0b', // Warna teks
          size: 10, // Ukuran font
          align: 'end', // Arahkan ke ujung
          anchor: 'end', // Ancor di ujung
          offset: 0.5// Offset spesifik untuk line chart
        }
      },
      {
        label: 'Actual',
        data: Object.values(actual),
        backgroundColor: Object.keys(planned).map((month, index) => {
          const plannedValue = planned[month];
          const actualValue = actual[month];
          return plannedValue >= actualValue ? '#a60b0b' : '#1FC216'; // Green if planned >= actual, red otherwise
        }),
        borderWidth: 1,
        type: 'bar',
        pointStyle: 'circle', // Gaya marker titik
        pointRadius: 5, // Ukuran marker titik
        pointHoverRadius: 8, // Ukuran marker titik saat dihover
        datalabels: {
          display: true, // Selalu tampilkan datalabels untuk dataset ini
          offset: -21, // Menggeser label 10 piksel ke bawah dari pusat batang
          anchor: 'end', // Anchor pada akhir bar sehingga muncul di atas bar
          align: 'top', // Arahkan ke atas
          color: 'white', // Warna teks
          font: {
            size: 10 // Ukuran font
          }
        }
      }
    ]
  };

  return (
    <div style={{
      width: size.width,
      height: size.height,
      paddingLeft: size.paddingLeft,
      paddingTop: size.paddingTop,
      marginTop: size.marginTop,
      paddingBottom: size.paddingBottom,
      marginLeft: '5px',
      marginRight: '5px',
      border: '2px solid #8b0000',
      boxShadow: '5px 5px 10px rgba(139, 0, 0.5)',
      borderRadius: '10px',
    }}>
      <Line data={chartData} options={options} />
      <div className="chart-description">
        <ul>
          <li>KPI Result: {kpiResult}</li>
          <li>KPI Factor Name: {kpiFactorName}</li>
          <li>Unit: {unit}</li>
          <li>Target: {target}</li>
        </ul>
      </div>
    </div>
  );
};

export default ChartComponent;

===================================
\
TANGGAL 24 JUNI


import React, { useState, useEffect } from 'react';
import { Bar, Line } from 'react-chartjs-2';
import { Chart } from 'chart.js/auto';
import '../Styles/chart.css';
import ChartDataLabels from 'chartjs-plugin-datalabels';
import { registerables } from 'chart.js';

function ChartComponent({ chartSize }) {
  const [chartData, setChartData] = useState([]);
  const [filteredChartData, setFilteredChartData] = useState([]);
  const [searchTerm, setSearchTerm] = useState('');
  const [activeSearchTerm, setActiveSearchTerm] = useState('');
  const [selectedItem, setSelectedItem] = useState('S'); // State untuk item yang dipilih
  const [selectedYears, setSelectedYears] = useState([]); // State untuk tahun yang dipilih
  const [availableYears, setAvailableYears] = useState([]); // State untuk menyimpan tahun yang tersedia
  const [dropdownOpen, setDropdownOpen] = useState(false); // State untuk dropdown

  Chart.register(...registerables, ChartDataLabels);

  const handleSearchChange = (event) => {
    setSearchTerm(event.target.value);
  };

  const handleSearch = () => {
    setActiveSearchTerm(searchTerm);
  };

  const handleRemoveFilter = () => {
    setSearchTerm('');
    setActiveSearchTerm('');
  };

  const handleItemChange = (event) => {
    setSelectedItem(event.target.value);
  };

  const toggleDropdown = () => {
    setDropdownOpen(!dropdownOpen);
  };

  const handleYearChange = (year) => {
    setSelectedYears((prevSelectedYears) =>
      prevSelectedYears.includes(year)
        ? prevSelectedYears.filter((y) => y !== year)
        : [...prevSelectedYears, year]
    );
  };

  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch('http://localhost:8080/kpi/item');
        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }
        const data = await response.json();
        console.log('Response JSON (item):', data);

        const formattedChartData = [];
        const years = new Set();

        data.data.forEach(item => {
          years.add(item.Year); // Menambahkan tahun ke set tahun
          if (item.Name === selectedItem) { // Filter berdasarkan item yang dipilih
            item.Results.forEach(result => {
              result.Factors.forEach(factor => {
                const plannedMonthly = factor.Planned?.Monthly[0] || {};
                const actualMonthly = factor.Actual?.Monthly[0] || {};
        
                formattedChartData.push({
                  kpiResult: result.Name,
                  kpiFactorName: factor.Title,
                  unit: factor.Unit,
                  target: factor.Target,
                  planned: {
                    January: plannedMonthly.January,
                    February: plannedMonthly.February,
                    March: plannedMonthly.March,
                    April: plannedMonthly.April,
                    May: plannedMonthly.May,
                    June: plannedMonthly.June,
                    July: plannedMonthly.July,
                    August: plannedMonthly.August,
                    September: plannedMonthly.September,
                    October: plannedMonthly.October,
                    November: plannedMonthly.November,
                    December: plannedMonthly.December,
                  },
                  actual: {
                    January: actualMonthly.January,
                    February: actualMonthly.February,
                    March: actualMonthly.March,
                    April: actualMonthly.April,
                    May: actualMonthly.May,
                    June: actualMonthly.June,
                    July: actualMonthly.July,
                    August: actualMonthly.August,
                    September: actualMonthly.September,
                    October: actualMonthly.October,
                    November: actualMonthly.November,
                    December: actualMonthly.December,
                  },
                  year: item.Year // Tambahkan informasi tahun
                });
              });
            });
          }
        });

        setAvailableYears(Array.from(years)); // Set tahun yang tersedia
        setChartData(formattedChartData);
        setFilteredChartData(formattedChartData);
      } catch (error) {
        console.error('Error fetching data', error);
      }
    };

    fetchData();
  }, [selectedItem]); // Menambahkan selectedItem sebagai dependency agar fetch ulang saat item berubah

  useEffect(() => {
    let filteredData = chartData;
    if (activeSearchTerm !== '') {
      filteredData = filteredData.filter(data =>
        data.kpiResult.toLowerCase().includes(activeSearchTerm.toLowerCase()) ||
        data.kpiFactorName.toLowerCase().includes(activeSearchTerm.toLowerCase())
      );
    }
    if (selectedYears.length > 0) {
      filteredData = filteredData.filter(data => selectedYears.includes(data.year));
    }
    setFilteredChartData(filteredData);
  }, [activeSearchTerm, selectedYears, chartData]);

  const chartOptions = {
    plugins: {
      title: {
        display: true,
        text: `Tabel Data Tahun ${selectedYears.join(', ')}`, // Menampilkan tahun yang dipilih
        padding: {
          top: 0,
          bottom: 5
        },
        font: {
          size: 18,
          weight: 'bold'
        }
      },
      datalabels: {
        display: true,
        formatter: function (value) {
          return value;
        },
        color: 'white' // Mengatur warna angka menjadi putih
      }
    },
    scales: {
      x: {
        type: 'category',
      },
      y: {
        beginAtZero: false, // Mulai dari 0
        min:0.0, // Nilai minimum
        barPercentage: 0.8,
        categoryPercentage: 0.9,
      },
    },
  };

  const gradientColor = (context, isExceedTarget = true) => {
    const gradient = context.chart.ctx.createLinearGradient(0, 0, 0, 300);
    if (isExceedTarget) {
      gradient.addColorStop(0, '#FF0000'); // Warna merah
      gradient.addColorStop(1, '#8b0000'); // Warna merah tua
    } else {
      gradient.addColorStop(0, '#00FF00'); // Warna hijau
      gradient.addColorStop(1, '#FFFF00'); // Warna kuning
    }
    return gradient;
  };

  return (
    <div className='chart'>
      <div style={{ textAlign: 'left', marginBottom: '0px', marginTop: '60px', marginLeft: '140px', marginBottom:"50px" }}>
         <div style={{marginTop:"0px", width:"calc(100% - 18px)", marginLeft:"1px", marginBottom:"10px" }} className="filter-containers">
          
        <select 
          id="item-select"

          onChange={handleItemChange} value={selectedItem}>
          <option value="S">Safety</option>
          <option value="E">Environment</option>
          <option value="Q">Quality</option>
          <option value="C">Cost</option>
          <option value="D">Delivery</option>
        </select>

        <div className="dropdown">
          <button onClick={toggleDropdown} className="dropdown-button">
            Pilih Tahun
          </button>
          {dropdownOpen && (
            <div className="dropdown-content">
              {availableYears.map((year, index) => (
                <label key={index} className="dropdown-item">
                  <input
                    type="checkbox"
                    value={year}
                    checked={selectedYears.includes(year)}
                    onChange={() => handleYearChange(year)}
                  />
                  {year}
                </label>
              ))}
            </div>
          )}
        </div>
        </div>
        <input type="text" placeholder="Search KPI Result or Factor..." onChange={handleSearchChange} />
        <div className='search'>
          <button onClick={handleSearch}>Search</button>
          <button onClick={handleRemoveFilter} style={{ marginLeft: '7px' }}>Remove Filter</button>
        </div>
        <div style={{ display: 'flex', justifyContent: 'center', gap: '10px', flexWrap: 'wrap' }}>
          {filteredChartData.length === 0 ? (
            <p style={{ backgroundColor: '#8b0000', borderRadius: '5px', color: 'white', padding: '10px' }}>Data not available for this item!</p>
          ) : (
            filteredChartData.map((data, index) => (
              <ChartContainer
                key={index}
                data={data}
                options={{ ...chartOptions, plugins: { ...chartOptions.plugins, title: { ...chartOptions.plugins.title, text: `Tabel Data Tahun ${data.year}` } } }} // Set judul chart sesuai dengan tahun
                size={chartSize}
                gradientColor={gradientColor}
              />
            ))
          )}
        </div>
      </div>
    </div>
  );
}



const ChartContainer = ({ data, options, size, gradientColor }) => {
  const { kpiResult, kpiFactorName, unit, target, planned, actual, year } = data;

  // Prepare chart data
  const chartData = {
    labels: Object.keys(planned),
    datasets: [
      {
        label: 'Planned',
        data: Object.values(planned),
        borderColor: gradientColor,
        backgroundColor: Object.keys(planned).map((month, index) => {
          const plannedValue = planned[month];
          const actualValue = actual[month];
          return plannedValue > actualValue ? '#a60b0b' : '#1FC216'; // Green if planned >= actual, red otherwise
        }),        
        fill: false,
        type: 'line',
        borderWidth: 2, // Lebar batas target
        type: 'line', // Jenis chart (line)
        fill: false, // Tidak diisi dengan warna
        pointStyle: 'circle', // Gaya marker titik
        pointRadius: 5, // Ukuran marker titik
        pointHoverRadius: 8, // Ukuran marker titik saat dihover
        datalabels: {
          display: true, // Selalu tampilkan datalabels untuk dataset ini
          color: '#a60b0b', // Warna teks
          size: 10, // Ukuran font
          align: 'end', // Arahkan ke ujung
          anchor: 'end', // Ancor di ujung
          offset: 0.5// Offset spesifik untuk line chart
        }
      },
      {
        label: 'Actual',
        data: Object.values(actual),
        backgroundColor: Object.keys(planned).map((month, index) => {
          const plannedValue = planned[month];
          const actualValue = actual[month];
          return plannedValue > actualValue ? '#a60b0b' : '#1FC216'; // Green if planned >= actual, red otherwise
        }),
        borderWidth: 1,
        type: 'bar',
        pointStyle: 'circle', // Gaya marker titik
        pointRadius: 5, // Ukuran marker titik
        pointHoverRadius: 8, // Ukuran marker titik saat dihover
        datalabels: {
          display: true, // Selalu tampilkan datalabels untuk dataset ini
          offset: -21, // Menggeser label 10 piksel ke bawah dari pusat batang
          anchor: 'end', // Anchor pada akhir bar sehingga muncul di atas bar
          align: 'top', // Arahkan ke atas
          color: 'white', // Warna teks
          font: {
            size: 10 // Ukuran font
          }
        }
      }
    ]
  };

  return (
    <div style={{
      width: size.width,
      height: size.height,
      paddingLeft: size.paddingLeft,
      paddingTop: size.paddingTop,
      marginTop: size.marginTop,
      paddingBottom: size.paddingBottom,
      marginLeft: '5px',
      marginRight: '5px',
      border: '2px solid #8b0000',
      boxShadow: '5px 5px 10px rgba(139, 0, 0.5)',
      borderRadius: '10px',
    }}>
      <Line data={chartData} options={options} />
      <div className="chart-description">
        <ul>
          <li>KPI Result: {kpiResult}</li>
          <li>KPI Factor Name: {kpiFactorName}</li>
          <li>Unit: {unit}</li>
          <li>Target: {target}</li>
        </ul>
      </div>
    </div>
  );
};

export default ChartComponent;

================================

import React, { useState, useEffect } from "react";
import "../Styles/dropdowns.css";
import * as XLSX from 'xlsx';


const EditUploadTableAnalysis = () => {
  const [problemsByYear, setProblemsByYear] = useState({});
  const [availableYears, setAvailableYears] = useState([]);
  const [selectedYears, setSelectedYears] = useState([]);
  const [dropdownOpen, setDropdownOpen] = useState(false);
  const [editMode, setEditMode] = useState(false);
  const [originalValues, setOriginalValues] = useState({});
  const [newRows, setNewRows] = useState([]); // State untuk menyimpan baris-baris data baru

  useEffect(() => {
    fetchMasalahData();
  }, []);

  const fetchMasalahData = async () => {
    try {
      const response = await fetch("http://localhost:8080/kpi/masalah");
      if (response.ok) {
        const responseData = await response.json();
        const data = responseData.data;
        console.log("Received data:", data);

        // Group problems by year
        const groupedProblems = {};
        data.forEach(problem => {
          if (!groupedProblems[problem.Year]) {
            groupedProblems[problem.Year] = [];
          }
          groupedProblems[problem.Year].push(problem);
        });

        setProblemsByYear(groupedProblems);

        // Extract available years
        const years = Object.keys(groupedProblems);
        setAvailableYears(years);
        setSelectedYears(years); // Initially select all years
      } else {
        console.error("Failed to fetch masalah data:", response.statusText);
      }
    } catch (error) {
      console.error("Error fetching masalah data:", error);
    }
  };

  const [selectedFile, setSelectedFile] = useState(null);
  const [fileData, setFileData] = useState(null);

  // This function handles file selection
  const handleFileChange = (event) => {
    const file = event.target.files[0];
    console.log('File selected:', file); // Log the selected file
    setSelectedFile(file); // Set the selected file to the state

    // Read the file data for preview purposes (optional)
    if (file) {
      const reader = new FileReader();
      reader.onload = (event) => {
        const workbook = XLSX.read(event.target.result, { type: 'binary' });
        const sheetName = workbook.SheetNames[0];
        const sheet = workbook.Sheets[sheetName];
        const data = XLSX.utils.sheet_to_json(sheet);
        setFileData(data); // Store parsed data for preview
      };
      reader.readAsBinaryString(file);
    }
  };

    // This function handles file upload
    const handleFileUpload = async () => {
      if (selectedFile) { // Check if a file is selected
        try {
          console.log('Preparing to upload file:', selectedFile); // Log before uploading
  
          const formData = new FormData();
          formData.append('file', selectedFile); // Append the actual file to FormData
  
          const response = await fetch('http://localhost:8080/kpi/file/analisa', {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${localStorage.getItem('authToken')}`,
              // 'Content-Type' is not needed; 'fetch' sets it automatically when FormData is used.
            },
            body: formData // Send the FormData containing the file
          });
  
          if (response.ok) {
            console.log('File uploaded successfully'); // Log success
            alert('File berhasil diunggah dan data diproses');
            window.location.reload(); // Refresh the page after successful upload
            // If you want to redirect to a specific URL, you can use:
            // window.location.href = 'your-target-url';
          } else {
            const errorText = await response.text();
            console.error('Failed to upload file:', errorText); // Log the error message
            alert(`Gagal mengunggah file: ${errorText}`);
          }
        } catch (error) {
          console.error('Error uploading file:', error); // Log the error
          alert('Error uploading file: ' + error.message);
        }
      } else {
        alert('Harap pilih file terlebih dahulu');
      }
    };

  const toggleDropdown = () => {
    setDropdownOpen(!dropdownOpen);
  };

  const handleYearChange = (year) => {
    const updatedSelectedYears = selectedYears.includes(year)
      ? selectedYears.filter(selectedYear => selectedYear !== year)
      : [...selectedYears, year];
    setSelectedYears(updatedSelectedYears);
  };

  // Definisi fetchData
const fetchData = async () => {
  try {
    // Lakukan permintaan fetch data yang diperlukan dari server
    const response = await fetch("http://localhost:8080/kpi/masalah");
    if (response.ok) {
      const responseData = await response.json();
      const data = responseData.data;
      console.log("Received data:", data);

      // Group problems by year
      const groupedProblems = {};
      data.forEach(problem => {
        if (!groupedProblems[problem.Year]) {
          groupedProblems[problem.Year] = [];
        }
        groupedProblems[problem.Year].push(problem);
      });

      // Setel state dengan data yang baru didapat
      setProblemsByYear(groupedProblems);

      // Extract available years
      const years = Object.keys(groupedProblems);
      setAvailableYears(years);
      setSelectedYears(years); // Initially select all years
    } else {
      console.error("Failed to fetch masalah data:", response.statusText);
    }
  } catch (error) {
    console.error("Error fetching masalah data:", error);
  }
};


  const handleDeleteAllData = async (year) => {
    if (window.confirm(`Apakah Anda yakin ingin menghapus semua data pada tahun ${year}?`)) {
      try {
        const authToken = localStorage.getItem("authToken");
  
        // Ambil masalah_id untuk semua masalah pada tahun yang dipilih
        const masalahIds = problemsByYear[year].map(problem => problem.Masalah_ID);
  
        // Buat array of promises untuk mengirim permintaan DELETE untuk setiap masalah_id
        const deleteRequests = masalahIds.map(masalahId =>
          fetch(`http://localhost:8080/kpi/masalah/${masalahId}`, {
            method: "DELETE",
            headers: {
              Authorization: `Bearer ${authToken}`,
            },
          })
        );
  
        // Lakukan penghapusan data dengan Promise.all
        const responses = await Promise.all(deleteRequests);
  
        // Periksa apakah semua permintaan berhasil
        const allSucceeded = responses.every(response => response.ok);
  
        if (allSucceeded) {
          console.log('All data deleted successfully');
          fetchData(); // Refresh data after deletion
        } else {
          throw new Error("Failed to delete all data");
        }
      } catch (error) {
        console.error("Error deleting all data:", error.message);
      }
    }
  };
  

  const handleDeleteRowClick = async (year, index, masalahID) => {
    const userConfirmed = window.confirm("Apakah anda yakin ingin menghapus row ini?");
    if (!userConfirmed) {
      return; // Exit the function if the user cancels the deletion
    }
    try {
      const authToken = localStorage.getItem("authToken");
      const response = await fetch(`http://localhost:8080/kpi/masalah/${masalahID}`, {
        method: "DELETE",
        headers: {
          "Authorization": `Bearer ${authToken}`
        }
      });
      if (response.ok) {
        const updatedProblems = [...problemsByYear[year]];
        updatedProblems.splice(index, 1);
        setProblemsByYear({
          ...problemsByYear,
          [year]: updatedProblems
        });
        console.log("Row deleted successfully");
      } else {
        console.error("Failed to delete row:", response.statusText);
      }
    } catch (error) {
      console.error("Error deleting row:", error);
    }
  };

  

  const handleDeleteNewRowClick = (year, index) => {
    const userConfirmed = window.confirm("Apakah anda yakin ingin menghapus row ini?");
    if (!userConfirmed) {
      return; // Exit the function if the user cancels the deletion
    }
    setNewRows(prevState => ({
      ...prevState,
      [year]: prevState[year].filter((_, idx) => idx !== index)
    }));
  };

  const handleEditClick = () => {
    setEditMode(true);
    const originalValuesCopy = {};
    selectedYears.forEach(year => {
      originalValuesCopy[year] = [...problemsByYear[year]];
    });
    setOriginalValues(originalValuesCopy);

    // Inisialisasi objek baris baru untuk setiap tahun yang dipilih
    const newRowsCopy = {};
    selectedYears.forEach(year => {
      newRowsCopy[year] = [];
    });
    setNewRows(newRowsCopy);
  };

  const handleAddRowClick = (year) => {
    const newRow = {
      Masalah: "",
      Why: ["", "", "", "", ""],
      Tindakan: "",
      Pic: "",
      Target: "",
      FolDate: "",
      Status: "",
      Year: year
    };

    setNewRows(prevState => ({
      ...prevState,
      [year]: [...(prevState[year] || []), newRow]
    }));
  };

  const handleSaveClick = async () => {
    const authToken = localStorage.getItem('authToken');
  
    try {
      const promises = [];
  
      selectedYears.forEach(year => {
        const updatedProblems = problemsByYear[year];
        updatedProblems.forEach(problem => {
          const formData = {
            Masalah_ID: problem.Masalah_ID,
            Masalah: problem.Masalah,
            Why: problem.Why,
            tindakan: problem.Tindakan,
            pic: problem.Pic,
            target: problem.Target,
            folDate: new Date(problem.FolDate).toISOString(),
            status: problem.Status,
            Year: problem.Year
          };
          
          console.log("Data yang dikirim ke server:", formData); // Tambahkan console log untuk body JSON
  
          promises.push(fetch(`http://localhost:8080/kpi/masalah/${problem.Masalah_ID}`, {
            method: "PUT",
            headers: {
              'Content-Type': 'application/json',
              "Authorization": `Bearer ${authToken}`
            },
            body: JSON.stringify(formData)
          }));
        });
  
        // Tambahkan data baru ke promises untuk dikirim ke server
      // Tambahkan data baru ke promises untuk dikirim ke server
      const newRowsForYear = newRows[year] || [];
      newRowsForYear.forEach(newRow => {
        const { Masalah_ID, ...formDataWithoutID } = newRow; // Destructure and remove Masalah_ID
        const formData = {
          ...formDataWithoutID,
          Why: [
            newRow.Why[0],
            newRow.Why[1],
            newRow.Why[2],
            newRow.Why[3],
            newRow.Why[4],
          ],
          FolDate: new Date(newRow.FolDate).toISOString(), // Ensure FolDate is converted to ISO string format
          Year: parseInt(newRow.Year) // Ensure Year is sent as an integer
        };
        
  console.log("Data yang dikirim ke server:", formData); // Tambahkan console log untuk body JSON

  promises.push(fetch(`http://localhost:8080/kpi/masalah`, {
    method: "POST",
    headers: {
      'Content-Type': 'application/json',
      "Authorization": `Bearer ${authToken}`
    },
    body: JSON.stringify(formData)
  }));
});

      });
  
      await Promise.all(promises);
      setEditMode(false);
      console.log("Data saved successfully.");
      fetchMasalahData(); // Refresh data setelah penyimpanan
     setProblemsByYear({});
    setNewRows({});
    } catch (error) {
      console.error("Failed to save data:", error);
    }
  };

  
  

        return (
          <div>
            <div className="container">
               <div style={{marginBottom:"10px"}} className="filter-containers">
              <div className="dropdown">
            <button onClick={toggleDropdown} className="dropdown-button">
              Filter Tahun
            </button>
            {dropdownOpen && (
              <div className="dropdown-content">
                {availableYears.map((year, index) => (
                  <label key={index} className="dropdown-item">
                    <input
                      type="checkbox"
                      value={year}
                      checked={selectedYears.includes(year)}
                      onChange={() => handleYearChange(year)}
                    />
                    {year}
                  </label>
                ))}
              </div>
            )}

            
          </div>

          
          
          <div className="savechanges">
            {!editMode && (
              <button onClick={handleEditClick}>Update Data Table</button>
            )}
          
            {editMode && (
              <button onClick={handleSaveClick}>Save Changes</button>
            )}
            </div>
    
           </div>

          
       </div>

       
       <div className='inputfile' style={{ marginLeft:"22px", display: 'flex', alignItems: 'center', marginBottom: '5px',  width: 'calc(100% - 43px)'}}>
  <input type="file" onChange={handleFileChange} style={{ marginRight: '13px' }} />
  <button onClick={handleFileUpload} style={{ padding: '5px 10px', borderRadius: '5px', backgroundImage: 'linear-gradient(to right, rgb(26, 171, 0), rgb(12, 217, 29))', color: 'white', border: 'none',  marginRight:"3px" }}>Upload Data</button>
</div>



      {selectedYears.map(year => (
        <div key={year} className="table-containers">
          <table className="dropdowns-safety">
            <caption>Saved Analysis Table for {year}</caption>
            <thead>
              <tr>
                <th rowSpan="2">Problem
                <div className="savechanges">

                <div>
                  {editMode && (
                    <button onClick={() => handleAddRowClick(year)}>Add</button>
                  )}
                  </div>
                  </div>

                </th>
                <th colSpan="5">Causes Analysis</th>
                <th rowSpan="2">Corrective Action</th>
                <th rowSpan="2">PIC</th>
                <th rowSpan="2">Target</th>
                <th colSpan="2">Follow Up</th>
              </tr>
              <tr>
                <th>Why 1</th>
                <th>Why 2</th>
                <th>Why 3</th>
                <th>Why 4</th>
                <th>Why 5</th>
                <th>Date</th>
                <th>Status</th>
              </tr>
            </thead>
            <tbody>
              {(problemsByYear[year] || []).map((problem, index) => (
                <tr key={`${year}_${index}_${problem.Masalah_ID || ''}`}>
                  <td>
                  <div className="delete">

                    {editMode ? (
                      <textarea
                        value={problem.Masalah || ""}
                        onChange={e => {
                          const updatedProblems = [...problemsByYear[year]];
                          const updatedProblem = { ...problem };
                          updatedProblem.Masalah = e.target.value;
                          updatedProblems[index] = updatedProblem;

                          setProblemsByYear({
                            ...problemsByYear,
                            [year]: updatedProblems
                          });
                        }}
                        style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                        placeholder={problem.Masalah}
                      />
                    ) : (
                      problem.Masalah
                    )}
                    <div>
                 {editMode && (
                    <button onClick={() => handleDeleteRowClick(year, index, problem.Masalah_ID)}>Delete</button>
                  )}
                  </div>
                  </div>
                  </td>
                  <td>
                    {editMode ? (
                      <textarea
                        value={problem.Why[0]}
                        onChange={e => {
                          const updatedProblems = [...problemsByYear[year]];
                          updatedProblems[index].Why[0] = e.target.value;
                          setProblemsByYear({
                            ...problemsByYear,
                            [year]: updatedProblems
                          });
                          
                        }}
                        style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                        placeholder={problem.Why[0]}
                      />
                      
                    ) : (
                      problem.Why[0]
                    )}
                  </td>
                  <td>
                    {editMode ? (
                      <textarea
                        value={problem.Why[1]}
                        onChange={e => {
                          const updatedProblems = [...problemsByYear[year]];
                          updatedProblems[index].Why[1] = e.target.value;
                          setProblemsByYear({
                            ...problemsByYear,
                            [year]: updatedProblems
                          });
                        }}
                        style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                        placeholder={problem.Why[1]}
                      />
                    ) : (
                      problem.Why[1]
                    )}
                  </td>
                  <td>
                    {editMode ? (
                      <textarea
                        value={problem.Why[2]}
                        onChange={e => {
                          const updatedProblems = [...problemsByYear[year]];
                          updatedProblems[index].Why[2] = e.target.value;
                          setProblemsByYear({
                            ...problemsByYear,
                            [year]: updatedProblems
                          });
                        }}
                        style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                        placeholder={problem.Why[2]}
                      />
                    ) : (
                      problem.Why[2]
                    )}
                  </td>
                  <td>
                    {editMode ? (
                      <textarea
                        value={problem.Why[3]}
                        onChange={e => {
                          const updatedProblems = [...problemsByYear[year]];
                          updatedProblems[index].Why[3] = e.target.value;
                          setProblemsByYear({
                            ...problemsByYear,
                            [year]: updatedProblems
                          });
                        }}
                        style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                        placeholder={problem.Why[3]}
                      />
                    ) : (
                      problem.Why[3]
                    )}
                  </td>
                  <td>
                    {editMode ? (
                      <textarea
                        value={problem.Why[4]}
                        onChange={e => {
                          const updatedProblems = [...problemsByYear[year]];
                          updatedProblems[index].Why[4] = e.target.value;
                          setProblemsByYear({
                            ...problemsByYear,
                            [year]: updatedProblems
                          });
                        }}
                        style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                        placeholder={problem.Why[4]}
                      />
                    ) : (
                      problem.Why[4]
                    )}
                  </td>
                  <td>
                    {editMode ? (
                      <textarea
                        value={problem.Tindakan}
                        onChange={e => {
                          const updatedProblems = [...problemsByYear[year]];
                          updatedProblems[index].Tindakan = e.target.value;
                          setProblemsByYear({
                            ...problemsByYear,
                            [year]: updatedProblems
                          });
                        }}
                        style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                        placeholder={problem.Tindakan}
                      />
                    ) : (
                      problem.Tindakan
                    )}
                  </td>
                  <td>
                    {editMode ? (
                      <textarea
                        value={problem.Pic}
                        onChange={e => {
                          const updatedProblems = [...problemsByYear[year]];
                          updatedProblems[index].Pic = e.target.value;
                          setProblemsByYear({
                            ...problemsByYear,
                            [year]: updatedProblems
                          });
                        }}
                        style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                        placeholder={problem.Pic}
                      />
                    ) : (
                      problem.Pic
                    )}
                  </td>
                  <td>
                    {editMode ? (
                      <textarea
                        value={problem.Target}
                        onChange={e => {
                          const updatedProblems = [...problemsByYear[year]];
                          updatedProblems[index].Target = e.target.value;
                          setProblemsByYear({
                            ...problemsByYear,
                            [year]: updatedProblems
                          });
                        }}
                        style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                        placeholder={problem.Target}
                      />
                    ) : (
                      problem.Target
                    )}
                  </td>
                  <td>
                    {editMode ? (
                      <input
                        type="datetime-local"
                        value={problem.FolDate}
                        onChange={e => {
                          const updatedProblems = [...problemsByYear[year]];
                          updatedProblems[index].FolDate = e.target.value;
                          setProblemsByYear({
                            ...problemsByYear,
                            [year]: updatedProblems
                          });
                        }}
                        className="custominput"
                        placeholder="Format : YYYY-MM-DDTHH:MM:SS+07:00"
                      />
                    ) : (
                      <span>{problem.FolDate}</span>
                    )}

                  </td>
                  <td>
                    {editMode ? (
                      <textarea
                        value={problem.Status}
                        onChange={e => {
                          const updatedProblems = [...problemsByYear[year]];
                          updatedProblems[index].Status = e.target.value;
                          setProblemsByYear({
                            ...problemsByYear,
                            [year]: updatedProblems
                          });
                        }}
                        style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                        placeholder={problem.Status}
                      />
                    ) : (
                      problem.Status
                    )}
                  </td>
                </tr>
              ))}
              {(newRows[year] || []).map((newRow, index) => (
                <tr key={`${year}_new_${index}`}>
                  <td>
                    <textarea
                      value={newRow.Masalah || ""}
                      onChange={e => {
                        const updatedNewRows = { ...newRows };
                        updatedNewRows[year][index].Masalah = e.target.value;
                        setNewRows(updatedNewRows);
                      }}
                      style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                      placeholder="Masalah"
                    />
                    <div>
                    <div className="delete">
                <button onClick={() => handleDeleteNewRowClick(year, index)}>Delete</button>
                </div>
                </div>

                  </td>
                  <td>
                    <textarea
                      value={newRow.Why[0] || ""}
                      onChange={e => {
                        const updatedNewRows = { ...newRows };
                        updatedNewRows[year][index].Why[0] = e.target.value;
                        setNewRows(updatedNewRows);
                      }}
                      style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                      placeholder="Why 1"
                    />
                  </td>
                  <td>
                    <textarea
                      value={newRow.Why[1] || ""}
                      onChange={e => {
                        const updatedNewRows = { ...newRows };
                        updatedNewRows[year][index].Why[1] = e.target.value;
                        setNewRows(updatedNewRows);
                      }}
                      style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                      placeholder="Why 2"
                    />
                  </td>
                  <td>
                    <textarea
                      value={newRow.Why[2] || ""}
                      onChange={e => {
                        const updatedNewRows = { ...newRows };
                        updatedNewRows[year][index].Why[2] = e.target.value;
                        setNewRows(updatedNewRows);
                      }}
                      style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                      placeholder="Why 3"
                    />
                  </td>
                  <td>
                    <textarea
                      value={newRow.Why[3] || ""}
                      onChange={e => {
                        const updatedNewRows = { ...newRows };
                        updatedNewRows[year][index].Why[3] = e.target.value;
                        setNewRows(updatedNewRows);
                      }}
                      style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                      placeholder="Why 4"
                    />
                  </td>
                  <td>
                    <textarea
                      value={newRow.Why[4] || ""}
                      onChange={e => {
                        const updatedNewRows = { ...newRows };
                        updatedNewRows[year][index].Why[4] = e.target.value;
                        setNewRows(updatedNewRows);
                      }}
                      style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                      placeholder="Why 5"
                    />
                  </td>
                  <td>
                    <textarea
                      value={newRow.Tindakan || ""}
                      onChange={e => {
                        const updatedNewRows = { ...newRows };
                        updatedNewRows[year][index].Tindakan = e.target.value;
                        setNewRows(updatedNewRows);
                      }}
                      style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                      placeholder="Tindakan"
                    />
                  </td>
                  <td>
                    <textarea
                      value={newRow.Pic || ""}
                      onChange={e => {
                        const updatedNewRows = { ...newRows };
                        updatedNewRows[year][index].Pic = e.target.value;
                        setNewRows(updatedNewRows);
                      }}
                      style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                      placeholder="PIC"
                    />
                  </td>
                  <td>
                    <textarea
                      value={newRow.Target || ""}
                      onChange={e => {
                        const updatedNewRows = { ...newRows };
                        updatedNewRows[year][index].Target = e.target.value;
                        setNewRows(updatedNewRows);
                      }}
                      style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                      placeholder="Target"
                    />
                  </td>
                  <td>
                    <input
                      type="datetime-local"
                      value={newRow.FolDate || ""}
                      onChange={e => {
                        const updatedNewRows = { ...newRows };
                        updatedNewRows[year][index].FolDate = e.target.value;
                        setNewRows(updatedNewRows);
                      }}
 
                      placeholder="Date"
                    />
                  </td>
                  <td>
                    <textarea
                      value={newRow.Status || ""}
                      onChange={e => {
                        const updatedNewRows = { ...newRows };
                        updatedNewRows[year][index].Status = e.target.value;
                        setNewRows(updatedNewRows);
                      }}
                      style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                      placeholder="Status"
                    />
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
           <div style={{display:"flex"}}>
                <div style={{marginRight:"20px"}} className="compare">
              {editMode && (
                            <button onClick={() => handleDeleteAllData(year)}>Delete All Data for {year}</button>

                )}
            </div>      
          </div>
            </div>
       ))}
    </div>
  );
};

export default EditUploadTableAnalysis;

========================================


import React, { useState, useEffect } from "react";
import "../Styles/dropdowns.css";
import * as XLSX from 'xlsx';



const EditUploadTableAnalysis = () => {
  const [problemsByYear, setProblemsByYear] = useState({});
  const [availableYears, setAvailableYears] = useState([]);
  const [selectedYears, setSelectedYears] = useState([]);
  const [dropdownOpen, setDropdownOpen] = useState(false);
  const [editMode, setEditMode] = useState(false);
  const [originalValues, setOriginalValues] = useState({});
  const [newRows, setNewRows] = useState([]); // State untuk menyimpan baris-baris data baru

  useEffect(() => {
    fetchMasalahData();
  }, []);

  const fetchMasalahData = async () => {
    try {
      const response = await fetch("http://localhost:8080/kpi/masalah");
      if (response.ok) {
        const responseData = await response.json();
        const data = responseData.data;
        console.log("Received data:", data);

        // Group problems by year
        const groupedProblems = {};
        data.forEach(problem => {
          if (!groupedProblems[problem.Year]) {
            groupedProblems[problem.Year] = [];
          }
          groupedProblems[problem.Year].push(problem);
        });

        setProblemsByYear(groupedProblems);

        // Extract available years
        const years = Object.keys(groupedProblems);
        setAvailableYears(years);
        setSelectedYears(years); // Initially select all years
      } else {
        console.error("Failed to fetch masalah data:", response.statusText);
      }
    } catch (error) {
      console.error("Error fetching masalah data:", error);
    }
  };

  const [selectedFile, setSelectedFile] = useState(null);
  const [fileData, setFileData] = useState(null);

  // This function handles file selection
  const handleFileChange = (event) => {
    const file = event.target.files[0];
    console.log('File selected:', file); // Log the selected file
    setSelectedFile(file); // Set the selected file to the state

    // Read the file data for preview purposes (optional)
    if (file) {
      const reader = new FileReader();
      reader.onload = (event) => {
        const workbook = XLSX.read(event.target.result, { type: 'binary' });
        const sheetName = workbook.SheetNames[0];
        const sheet = workbook.Sheets[sheetName];
        const data = XLSX.utils.sheet_to_json(sheet);
        setFileData(data); // Store parsed data for preview
      };
      reader.readAsBinaryString(file);
    }
  };

    // This function handles file upload
    const handleFileUpload = async () => {
      if (selectedFile) { // Check if a file is selected
        try {
          console.log('Preparing to upload file:', selectedFile); // Log before uploading
  
          const formData = new FormData();
          formData.append('file', selectedFile); // Append the actual file to FormData
  
          const response = await fetch('http://localhost:8080/kpi/file/analisa', {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${localStorage.getItem('authToken')}`,
              // 'Content-Type' is not needed; 'fetch' sets it automatically when FormData is used.
            },
            body: formData // Send the FormData containing the file
          });
  
          if (response.ok) {
            console.log('File uploaded successfully'); // Log success
            alert('File berhasil diunggah dan data diproses');
            window.location.reload(); // Refresh the page after successful upload
            // If you want to redirect to a specific URL, you can use:
            // window.location.href = 'your-target-url';
          } else {
            const errorText = await response.text();
            console.error('Failed to upload file:', errorText); // Log the error message
            alert('Anda sudah mengupload data pada tahun tersebut, tolong lakukan update data apabila ingin mengelola data pada tahun tersebut!')
            // alert(`Gagal mengunggah file: ${errorText}`);
          }
        } catch (error) {
          console.error('Error uploading file:', error); // Log the error
          alert('Error uploading file: ' + error.message);
        }
      } else {
        alert('Harap pilih file terlebih dahulu');
      }
    };

  const toggleDropdown = () => {
    setDropdownOpen(!dropdownOpen);
  };

  const handleYearChange = (year) => {
    const updatedSelectedYears = selectedYears.includes(year)
      ? selectedYears.filter(selectedYear => selectedYear !== year)
      : [...selectedYears, year];
    setSelectedYears(updatedSelectedYears);
  };

  // Definisi fetchData
const fetchData = async () => {
  try {
    // Lakukan permintaan fetch data yang diperlukan dari server
    const response = await fetch("http://localhost:8080/kpi/masalah");
    if (response.ok) {
      const responseData = await response.json();
      const data = responseData.data;
      console.log("Received data:", data);

      // Group problems by year
      const groupedProblems = {};
      data.forEach(problem => {
        if (!groupedProblems[problem.Year]) {
          groupedProblems[problem.Year] = [];
        }
        groupedProblems[problem.Year].push(problem);
      });

      // Setel state dengan data yang baru didapat
      setProblemsByYear(groupedProblems);

      // Extract available years
      const years = Object.keys(groupedProblems);
      setAvailableYears(years);
      setSelectedYears(years); // Initially select all years
    } else {
      console.error("Failed to fetch masalah data:", response.statusText);
    }
  } catch (error) {
    console.error("Error fetching masalah data:", error);
  }
};


  const handleDeleteAllData = async (year) => {
    if (window.confirm(`Apakah Anda yakin ingin menghapus semua data pada tahun ${year}?`)) {
      try {
        const authToken = localStorage.getItem("authToken");
  
        // Ambil masalah_id untuk semua masalah pada tahun yang dipilih
        const masalahIds = problemsByYear[year].map(problem => problem.Masalah_ID);
  
        // Buat array of promises untuk mengirim permintaan DELETE untuk setiap masalah_id
        const deleteRequests = masalahIds.map(masalahId =>
          fetch(`http://localhost:8080/kpi/masalah/${masalahId}`, {
            method: "DELETE",
            headers: {
              Authorization: `Bearer ${authToken}`,
            },
          })
        );
  
        // Lakukan penghapusan data dengan Promise.all
        const responses = await Promise.all(deleteRequests);
  
        // Periksa apakah semua permintaan berhasil
        const allSucceeded = responses.every(response => response.ok);
  
        if (allSucceeded) {
          console.log('All data deleted successfully');
          fetchData(); // Refresh data after deletion
        } else {
          throw new Error("Failed to delete all data");
        }
      } catch (error) {
        console.error("Error deleting all data:", error.message);
      }
    }
  };
  

  const handleDeleteRowClick = async (year, index, masalahID) => {
    const userConfirmed = window.confirm("Apakah anda yakin ingin menghapus row ini?");
    if (!userConfirmed) {
      return; // Exit the function if the user cancels the deletion
    }
    try {
      const authToken = localStorage.getItem("authToken");
      const response = await fetch(`http://localhost:8080/kpi/masalah/${masalahID}`, {
        method: "DELETE",
        headers: {
          "Authorization": `Bearer ${authToken}`
        }
      });
      if (response.ok) {
        const updatedProblems = [...problemsByYear[year]];
        updatedProblems.splice(index, 1);
        setProblemsByYear({
          ...problemsByYear,
          [year]: updatedProblems
        });
        console.log("Row deleted successfully");
      } else {
        console.error("Failed to delete row:", response.statusText);
      }
    } catch (error) {
      console.error("Error deleting row:", error);
    }
  };

  

  const handleDeleteNewRowClick = (year, index) => {
    const userConfirmed = window.confirm("Apakah anda yakin ingin menghapus row ini?");
    if (!userConfirmed) {
      return; // Exit the function if the user cancels the deletion
    }
    setNewRows(prevState => ({
      ...prevState,
      [year]: prevState[year].filter((_, idx) => idx !== index)
    }));
  };

  const handleEditClick = () => {
    setEditMode(true);
    const originalValuesCopy = {};
    selectedYears.forEach(year => {
      originalValuesCopy[year] = [...problemsByYear[year]];
    });
    setOriginalValues(originalValuesCopy);

    // Inisialisasi objek baris baru untuk setiap tahun yang dipilih
    const newRowsCopy = {};
    selectedYears.forEach(year => {
      newRowsCopy[year] = [];
    });
    setNewRows(newRowsCopy);
  };

  const handleAddRowClick = (year) => {
    const newRow = {
      Masalah: "",
      Why: ["", "", "", "", ""],
      Tindakan: "",
      Pic: "",
      Target: "",
      FolDate: "",
      Status: "",
      Year: year
    };

    setNewRows(prevState => ({
      ...prevState,
      [year]: [...(prevState[year] || []), newRow]
    }));
  };

  const handleSaveClick = async () => {
    const authToken = localStorage.getItem('authToken');
  
    try {
      const promises = [];
  
      selectedYears.forEach(year => {
        const updatedProblems = problemsByYear[year];
        updatedProblems.forEach(problem => {
          const formData = {
            Masalah_ID: problem.Masalah_ID,
            Masalah: problem.Masalah,
            Why: problem.Why,
            tindakan: problem.Tindakan,
            pic: problem.Pic,
            target: problem.Target,
            folDate: new Date(problem.FolDate).toISOString(),
            status: problem.Status,
            Year: problem.Year
          };
          
          console.log("Data yang dikirim ke server:", formData); // Tambahkan console log untuk body JSON
  
          promises.push(fetch(`http://localhost:8080/kpi/masalah/${problem.Masalah_ID}`, {
            method: "PUT",
            headers: {
              'Content-Type': 'application/json',
              "Authorization": `Bearer ${authToken}`
            },
            body: JSON.stringify(formData)
          }));
        });
  
        // Tambahkan data baru ke promises untuk dikirim ke server
      // Tambahkan data baru ke promises untuk dikirim ke server
      const newRowsForYear = newRows[year] || [];
      newRowsForYear.forEach(newRow => {
        const { Masalah_ID, ...formDataWithoutID } = newRow; // Destructure and remove Masalah_ID
        const formData = {
          ...formDataWithoutID,
          Why: [
            newRow.Why[0],
            newRow.Why[1],
            newRow.Why[2],
            newRow.Why[3],
            newRow.Why[4],
          ],
          FolDate: new Date(newRow.FolDate).toISOString(), // Ensure FolDate is converted to ISO string format
          Year: parseInt(newRow.Year) // Ensure Year is sent as an integer
        };
        
  console.log("Data yang dikirim ke server:", formData); // Tambahkan console log untuk body JSON

  promises.push(fetch(`http://localhost:8080/kpi/masalah`, {
    method: "POST",
    headers: {
      'Content-Type': 'application/json',
      "Authorization": `Bearer ${authToken}`
    },
    body: JSON.stringify(formData)
  }));
});

      });
  
      await Promise.all(promises);
      setEditMode(false);
      console.log("Data saved successfully.");
      alert('Data berhasil disimpan!');
      fetchMasalahData(); // Refresh data setelah penyimpanan
     setProblemsByYear({});
    setNewRows({});
    } catch (error) {
      console.error("Failed to save data:", error);
      alert("Tolong login kembali atau pastikan tanggal pada setiap masalah sudah diisi");

    }
    
  };

  
  

        return (
          <div>
            <div className="container">
               <div style={{marginBottom:"10px"}} className="filter-containers">
              <div className="dropdown">
            <button onClick={toggleDropdown} className="dropdown-button">
              Filter Tahun
            </button>
            {dropdownOpen && (
              <div className="dropdown-content">
                {availableYears.map((year, index) => (
                  <label key={index} className="dropdown-item">
                    <input
                      type="checkbox"
                      value={year}
                      checked={selectedYears.includes(year)}
                      onChange={() => handleYearChange(year)}
                    />
                    {year}
                  </label>
                ))}
              </div>
            )}

            
          </div>

          
          
          <div className="savechanges">
            {!editMode && (
              <button onClick={handleEditClick}>Update Data Table</button>
            )}
          
            {editMode && (
              <button onClick={handleSaveClick}>Save Changes</button>
            )}
            </div>
    
           </div>

          
       </div>

       
       <div className='inputfile' style={{ marginLeft:"22px", display: 'flex', alignItems: 'center', marginBottom: '5px',  width: 'calc(100% - 43px)'}}>
  <input type="file" onChange={handleFileChange} style={{ marginRight: '13px' }} />
  <button onClick={handleFileUpload} style={{ padding: '5px 10px', borderRadius: '5px', backgroundImage: 'linear-gradient(to right, rgb(26, 171, 0), rgb(12, 217, 29))', color: 'white', border: 'none',  marginRight:"3px" }}>Upload Data</button>
</div>



      {selectedYears.map(year => (
        <div key={year} className="table-containers">
          <table className="dropdowns-safety">
            <caption>Saved Analysis Table for {year}</caption>
            <thead>
              <tr>
                <th rowSpan="2">Problem
                <div className="savechanges">

                <div>
                  {editMode && (
                    <button onClick={() => handleAddRowClick(year)}>Add</button>
                  )}
                  </div>
                  </div>

                </th>
                <th colSpan="5">Causes Analysis</th>
                <th rowSpan="2">Corrective Action</th>
                <th rowSpan="2">PIC</th>
                <th rowSpan="2">Target</th>
                <th colSpan="2">Follow Up</th>
              </tr>
              <tr>
                <th>Why 1</th>
                <th>Why 2</th>
                <th>Why 3</th>
                <th>Why 4</th>
                <th>Why 5</th>
                <th>Date</th>
                <th>Status</th>
              </tr>
            </thead>
            <tbody>
              {(problemsByYear[year] || []).map((problem, index) => (
                <tr key={`${year}_${index}_${problem.Masalah_ID || ''}`}>
                  <td>
                  <div className="delete">

                    {editMode ? (
                      <textarea
                        value={problem.Masalah || ""}
                        onChange={e => {
                          const updatedProblems = [...problemsByYear[year]];
                          const updatedProblem = { ...problem };
                          updatedProblem.Masalah = e.target.value;
                          updatedProblems[index] = updatedProblem;

                          setProblemsByYear({
                            ...problemsByYear,
                            [year]: updatedProblems
                          });
                        }}
                        style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                        placeholder={problem.Masalah}
                      />
                    ) : (
                      problem.Masalah
                    )}
                    <div>
                 {editMode && (
                    <button onClick={() => handleDeleteRowClick(year, index, problem.Masalah_ID)}>Delete</button>
                  )}
                  </div>
                  </div>
                  </td>
                  <td>
                    {editMode ? (
                      <textarea
                        value={problem.Why[0]}
                        onChange={e => {
                          const updatedProblems = [...problemsByYear[year]];
                          updatedProblems[index].Why[0] = e.target.value;
                          setProblemsByYear({
                            ...problemsByYear,
                            [year]: updatedProblems
                          });
                          
                        }}
                        style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                        placeholder={problem.Why[0]}
                      />
                      
                    ) : (
                      problem.Why[0]
                    )}
                  </td>
                  <td>
                    {editMode ? (
                      <textarea
                        value={problem.Why[1]}
                        onChange={e => {
                          const updatedProblems = [...problemsByYear[year]];
                          updatedProblems[index].Why[1] = e.target.value;
                          setProblemsByYear({
                            ...problemsByYear,
                            [year]: updatedProblems
                          });
                        }}
                        style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                        placeholder={problem.Why[1]}
                      />
                    ) : (
                      problem.Why[1]
                    )}
                  </td>
                  <td>
                    {editMode ? (
                      <textarea
                        value={problem.Why[2]}
                        onChange={e => {
                          const updatedProblems = [...problemsByYear[year]];
                          updatedProblems[index].Why[2] = e.target.value;
                          setProblemsByYear({
                            ...problemsByYear,
                            [year]: updatedProblems
                          });
                        }}
                        style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                        placeholder={problem.Why[2]}
                      />
                    ) : (
                      problem.Why[2]
                    )}
                  </td>
                  <td>
                    {editMode ? (
                      <textarea
                        value={problem.Why[3]}
                        onChange={e => {
                          const updatedProblems = [...problemsByYear[year]];
                          updatedProblems[index].Why[3] = e.target.value;
                          setProblemsByYear({
                            ...problemsByYear,
                            [year]: updatedProblems
                          });
                        }}
                        style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                        placeholder={problem.Why[3]}
                      />
                    ) : (
                      problem.Why[3]
                    )}
                  </td>
                  <td>
                    {editMode ? (
                      <textarea
                        value={problem.Why[4]}
                        onChange={e => {
                          const updatedProblems = [...problemsByYear[year]];
                          updatedProblems[index].Why[4] = e.target.value;
                          setProblemsByYear({
                            ...problemsByYear,
                            [year]: updatedProblems
                          });
                        }}
                        style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                        placeholder={problem.Why[4]}
                      />
                    ) : (
                      problem.Why[4]
                    )}
                  </td>
                  <td>
                    {editMode ? (
                      <textarea
                        value={problem.Tindakan}
                        onChange={e => {
                          const updatedProblems = [...problemsByYear[year]];
                          updatedProblems[index].Tindakan = e.target.value;
                          setProblemsByYear({
                            ...problemsByYear,
                            [year]: updatedProblems
                          });
                        }}
                        style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                        placeholder={problem.Tindakan}
                      />
                    ) : (
                      problem.Tindakan
                    )}
                  </td>
                  <td>
                    {editMode ? (
                      <textarea
                        value={problem.Pic}
                        onChange={e => {
                          const updatedProblems = [...problemsByYear[year]];
                          updatedProblems[index].Pic = e.target.value;
                          setProblemsByYear({
                            ...problemsByYear,
                            [year]: updatedProblems
                          });
                        }}
                        style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                        placeholder={problem.Pic}
                      />
                    ) : (
                      problem.Pic
                    )}
                  </td>
                  <td>
                    {editMode ? (
                      <textarea
                        value={problem.Target}
                        onChange={e => {
                          const updatedProblems = [...problemsByYear[year]];
                          updatedProblems[index].Target = e.target.value;
                          setProblemsByYear({
                            ...problemsByYear,
                            [year]: updatedProblems
                          });
                        }}
                        style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                        placeholder={problem.Target}
                      />
                    ) : (
                      problem.Target
                    )}
                  </td>
                  <td>
                    {editMode ? (
                      <input
                        type="datetime-local"
                        value={problem.FolDate}
                        onChange={e => {
                          const updatedProblems = [...problemsByYear[year]];
                          updatedProblems[index].FolDate = e.target.value;
                          setProblemsByYear({
                            ...problemsByYear,
                            [year]: updatedProblems
                          });
                        }}
                        className="custominput"
                        placeholder="Format : YYYY-MM-DDTHH:MM:SS+07:00"
                      />
                    ) : (
                      <span>{problem.FolDate}</span>
                    )}

                  </td>
                  <td>
                    {editMode ? (
                      <textarea
                        value={problem.Status}
                        onChange={e => {
                          const updatedProblems = [...problemsByYear[year]];
                          updatedProblems[index].Status = e.target.value;
                          setProblemsByYear({
                            ...problemsByYear,
                            [year]: updatedProblems
                          });
                        }}
                        style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                        placeholder={problem.Status}
                      />
                    ) : (
                      problem.Status
                    )}
                  </td>
                </tr>
              ))}
              {(newRows[year] || []).map((newRow, index) => (
                <tr key={`${year}_new_${index}`}>
                  <td>
                    <textarea
                      value={newRow.Masalah || ""}
                      onChange={e => {
                        const updatedNewRows = { ...newRows };
                        updatedNewRows[year][index].Masalah = e.target.value;
                        setNewRows(updatedNewRows);
                      }}
                      style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                      placeholder="Masalah"
                    />
                    <div>
                    <div className="delete">
                <button onClick={() => handleDeleteNewRowClick(year, index)}>Delete</button>
                </div>
                </div>

                  </td>
                  <td>
                    <textarea
                      value={newRow.Why[0] || ""}
                      onChange={e => {
                        const updatedNewRows = { ...newRows };
                        updatedNewRows[year][index].Why[0] = e.target.value;
                        setNewRows(updatedNewRows);
                      }}
                      style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                      placeholder="Why 1"
                    />
                  </td>
                  <td>
                    <textarea
                      value={newRow.Why[1] || ""}
                      onChange={e => {
                        const updatedNewRows = { ...newRows };
                        updatedNewRows[year][index].Why[1] = e.target.value;
                        setNewRows(updatedNewRows);
                      }}
                      style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                      placeholder="Why 2"
                    />
                  </td>
                  <td>
                    <textarea
                      value={newRow.Why[2] || ""}
                      onChange={e => {
                        const updatedNewRows = { ...newRows };
                        updatedNewRows[year][index].Why[2] = e.target.value;
                        setNewRows(updatedNewRows);
                      }}
                      style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                      placeholder="Why 3"
                    />
                  </td>
                  <td>
                    <textarea
                      value={newRow.Why[3] || ""}
                      onChange={e => {
                        const updatedNewRows = { ...newRows };
                        updatedNewRows[year][index].Why[3] = e.target.value;
                        setNewRows(updatedNewRows);
                      }}
                      style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                      placeholder="Why 4"
                    />
                  </td>
                  <td>
                    <textarea
                      value={newRow.Why[4] || ""}
                      onChange={e => {
                        const updatedNewRows = { ...newRows };
                        updatedNewRows[year][index].Why[4] = e.target.value;
                        setNewRows(updatedNewRows);
                      }}
                      style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                      placeholder="Why 5"
                    />
                  </td>
                  <td>
                    <textarea
                      value={newRow.Tindakan || ""}
                      onChange={e => {
                        const updatedNewRows = { ...newRows };
                        updatedNewRows[year][index].Tindakan = e.target.value;
                        setNewRows(updatedNewRows);
                      }}
                      style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                      placeholder="Tindakan"
                    />
                  </td>
                  <td>
                    <textarea
                      value={newRow.Pic || ""}
                      onChange={e => {
                        const updatedNewRows = { ...newRows };
                        updatedNewRows[year][index].Pic = e.target.value;
                        setNewRows(updatedNewRows);
                      }}
                      style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                      placeholder="PIC"
                    />
                  </td>
                  <td>
                    <textarea
                      value={newRow.Target || ""}
                      onChange={e => {
                        const updatedNewRows = { ...newRows };
                        updatedNewRows[year][index].Target = e.target.value;
                        setNewRows(updatedNewRows);
                      }}
                      style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                      placeholder="Target"
                    />
                  </td>
                  <td>
                    <input
                      type="datetime-local"
                      value={newRow.FolDate || ""}
                      onChange={e => {
                        const updatedNewRows = { ...newRows };
                        updatedNewRows[year][index].FolDate = e.target.value;
                        setNewRows(updatedNewRows);
                      }}
 
                      placeholder="Date"
                    />
                  </td>
                  <td>
                    <textarea
                      value={newRow.Status || ""}
                      onChange={e => {
                        const updatedNewRows = { ...newRows };
                        updatedNewRows[year][index].Status = e.target.value;
                        setNewRows(updatedNewRows);
                      }}
                      style={{ width: '100px', height: '50px' }} // Sesuaikan nilai width dan height sesuai kebutuhan

                      placeholder="Status"
                    />
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
           <div style={{display:"flex"}}>
                <div style={{marginRight:"20px"}} className="compare">
              {editMode && (
                            <button onClick={() => handleDeleteAllData(year)}>Delete All Data for {year}</button>

                )}
            </div>      
          </div>
            </div>
       ))}
    </div>
  );
};

export default EditUploadTableAnalysis;
