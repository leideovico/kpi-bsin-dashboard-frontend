import React, { useState, useEffect } from "react";
import "../Styles/savedsummary.css";

const SavedSummaryTable = () => {
  const [columns, setColumns] = useState([]);
  const [rows, setRows] = useState([]);
  const [tablesData, setTablesData] = useState({});
  const [comparisonData, setComparisonData] = useState({});
  const [warningMessage, setWarningMessage] = useState("");
  const [years, setYears] = useState([]);
  const [selectedYears, setSelectedYears] = useState([]);
  const [dropdownOpen, setDropdownOpen] = useState(false);

  const toggleDropdown = () => {
    setDropdownOpen(!dropdownOpen);
  };

  const handleCompareData = (issuedDate) => {
    const currentTable = tablesData[issuedDate];

    if (currentTable.columns.length < 2) {
      alert("Untuk melakukan perbandingan minimal harus memiliki 2 nama project!");
      return;
    }

    const comparisonResult = {
      columns: currentTable.columns.map((col1, index1) =>
        currentTable.columns.slice(index1 + 1).map((col2, index2) => ({
          id: `${col1.id}-${col2.id}`,
          name: `${col1.name} vs ${col2.name}`,
          item: `Diff Item ${col1.id} vs ${col2.id}`,
          quantity: `Diff Quantity ${col1.id} vs ${col2.id}`
        }))
      ).flat(),
      rows: currentTable.rows.map((row) => ({
        projectName: row.projectName,
        status: row.status.map((stat1, index1) =>
          row.status.slice(index1 + 1).map((stat2, index2) => ({
            id: `${stat1.id}-${stat2.id}`,
            name: Math.abs(stat1.name - stat2.name),
            quantity: Math.abs(stat1.quantity - stat2.quantity)
          }))
        ).flat(),
        remarks: row.remarks
      }))
    };

    setComparisonData((prevComparisonData) => ({
      ...prevComparisonData,
      [issuedDate]: comparisonResult
    }));
  };

  useEffect(() => {
    const fetchData = async () => {
      try {
        const authToken = localStorage.getItem("authToken");

        // Fetch summary data
        const summaryResponse = await fetch("http://localhost:8080/kpi/summary", {
          method: "GET",
          headers: {
            Authorization: `Bearer ${authToken}`,
          },
        });

        if (!summaryResponse.ok) {
          throw new Error("Failed to fetch summary data");
        }

        const summaryData = await summaryResponse.json();
        console.log("Fetched summary data:", summaryData);

        if (summaryData && summaryData.data && Array.isArray(summaryData.data)) {
          // Group summary data by issuedDate
          const tablesDataByIssuedDate = {};
          const yearsSet = new Set();
          summaryData.data.forEach((entry) => {
            const issuedDate = new Date(entry.IssuedDate).toLocaleDateString(); // Convert issuedDate to string format without time
            const year = new Date(entry.IssuedDate).getFullYear();
            yearsSet.add(year);
            if (!tablesDataByIssuedDate[issuedDate]) {
              tablesDataByIssuedDate[issuedDate] = {
                columns: [],
                rows: []
              };
            }

            if (tablesDataByIssuedDate[issuedDate].columns.length === 0) {
              // Extract columns
              tablesDataByIssuedDate[issuedDate].columns = entry.Projects.map((project, index) => ({
                id: index + 1,
                name: project.Name,
                item: `Item ${index + 1}`,
                quantity: `Quantity ${index + 1}`
              }));
            }

            // Process rows
            const processedRows = entry.Status.map((status, statusIndex) => ({
              projectName: status,
              category: "",
              status: entry.Projects.map((project, colIndex) => ({
                name: parseInt(project.Item[statusIndex], 10),
                quantity: parseInt(project.Quantity[statusIndex], 10),
                id: colIndex + 1,
                statuses: [{ name: parseInt(project.Quantity[statusIndex], 10), id: colIndex + 1 }]
              })),
              remarks: entry.Remarks && entry.Remarks[statusIndex] ? entry.Remarks[statusIndex] : "No remarks available"
            }));

            tablesDataByIssuedDate[issuedDate].rows.push(...processedRows);
          });

          setYears(Array.from(yearsSet));
          setSelectedYears(Array.from(yearsSet)); // Initially select all years
          setTablesData(tablesDataByIssuedDate);
        }
      } catch (error) {
        console.error("Error fetching data:", error.message);
      }
    };

    fetchData();
  }, []);

  const handleYearChange = (year) => {
    setSelectedYears((prevSelectedYears) =>
      prevSelectedYears.includes(year)
        ? prevSelectedYears.filter((y) => y !== year)
        : [...prevSelectedYears, year]
    );
  };

  return (
    <div>
      {warningMessage && <div className="warning">{warningMessage}</div>}
      <div className="filter-containers">
      <div className="dropdown">
        <button onClick={toggleDropdown} className="dropdown-button">
          Pilih Tahun
        </button>
        {dropdownOpen && (
          <div className="dropdown-content">
            {years.map((year, index) => (
              <label key={index} className="dropdown-item">
                <input
                  type="checkbox"
                  value={year}
                  checked={selectedYears.includes(year)}
                  onChange={() => handleYearChange(year)}
                />
                {year}
              </label>
            ))}
          </div>
        )}
      </div>
      </div>

      {Object.entries(tablesData)
        .filter(([issuedDate]) => selectedYears.includes(new Date(issuedDate).getFullYear()))
        .map(([issuedDate, tableData]) => (
          <div key={issuedDate} className="table-container">
            <table className="dropdowns-safety-sum">
              <caption>Summary Table {issuedDate}</caption>
              <thead>
                <tr>
                  <th rowSpan="2">Item Category Project</th>
                  {tableData.columns.map((col) => (
                    <th colSpan="2" key={col.id}>
                      {col.name}
                    </th>
                  ))}
                  <th rowSpan="2">Remarks</th>
                </tr>
                <tr>
                  {tableData.columns.map((col) => (
                    <React.Fragment key={col.id}>
                      <th>{col.item}</th>
                      <th>{col.quantity}</th>
                    </React.Fragment>
                  ))}
                </tr>
              </thead>
              <tbody>
                {tableData.rows.map((row, rowIndex) => (
                  <tr key={rowIndex}>
                    <td>{row.projectName}</td>
                    {row.status.map((stat) => (
                      <React.Fragment key={stat.id}>
                        <td>{stat.name}</td>
                        <td>{stat.quantity}</td>
                      </React.Fragment>
                    ))}
                    <td>{row.remarks}</td>
                  </tr>
                ))}
              </tbody>
            </table>
            <div className="compare">
              <button onClick={() => handleCompareData(issuedDate)}>Compare Data</button>
            </div>
          </div>
        ))}

      {Object.entries(comparisonData)
        .filter(([issuedDate]) => selectedYears.includes(new Date(issuedDate).getFullYear()))
        .map(([issuedDate, compData]) => (
          <div key={issuedDate} className="table-container">
            <hr /> {/* Section line above the comparison table */}
            <h2>Data Compared</h2>
            <table className="dropdowns-safety-sum">
              <caption>Comparison Table for {issuedDate}</caption>
              <thead>
                <tr>
                  <th rowSpan="2">Item Category Project</th>
                  {compData.columns.map((col) => (
                    <th colSpan="2" key={col.id}>
                      {col.name}
                    </th>
                  ))}
                  <th rowSpan="2">Remarks</th>
                </tr>
                <tr>
                  {compData.columns.map((col) => (
                    <React.Fragment key={col.id}>
                      <th>{col.item}</th>
                      <th>{col.quantity}</th>
                    </React.Fragment>
                  ))}
                </tr>
              </thead>
              <tbody>
                {compData.rows.map((row, rowIndex) => (
                  <tr key={rowIndex}>
                    <td>{row.projectName}</td>
                    {row.status.map((stat) => (
                      <React.Fragment key={stat.id}>
                        <td>{stat.name}</td>
                        <td>{stat.quantity}</td>
                      </React.Fragment>
                    ))}
                    <td>{row.remarks}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        ))}
    </div>
  );
};

export default SavedSummaryTable;

====

import React, { useState, useEffect } from "react";
import "../Styles/savedsummary.css";

const SavedSummaryTable = () => {
  const [columns, setColumns] = useState([]);
  const [rows, setRows] = useState([]);
  const [tablesData, setTablesData] = useState({});
  const [comparisonData, setComparisonData] = useState({});
  const [warningMessage, setWarningMessage] = useState("");
  const [years, setYears] = useState([]);
  const [selectedYears, setSelectedYears] = useState([]);
  const [dropdownOpen, setDropdownOpen] = useState(false);
  const [editMode, setEditMode] = useState(false); // state untuk mode edit
  const [editTableData, setEditTableData] = useState({}); // state untuk data yang diubah

  const toggleDropdown = () => {
    setDropdownOpen(!dropdownOpen);
  };

  const handleCompareData = (issuedDate) => {
    const currentTable = tablesData[issuedDate];

    if (currentTable.columns.length < 2) {
      alert("Untuk melakukan perbandingan minimal harus memiliki 2 nama project!");
      return;
    }

    const comparisonResult = {
      columns: currentTable.columns.map((col1, index1) =>
        currentTable.columns.slice(index1 + 1).map((col2, index2) => ({
          id: `${col1.id}-${col2.id}`,
          name: `${col1.name} vs ${col2.name}`,
          item: `Diff Item ${col1.id} vs ${col2.id}`,
          quantity: `Diff Quantity ${col1.id} vs ${col2.id}`
        }))
      ).flat(),
      rows: currentTable.rows.map((row) => ({
        projectName: row.projectName,
        status: row.status.map((stat1, index1) =>
          row.status.slice(index1 + 1).map((stat2, index2) => ({
            id: `${stat1.id}-${stat2.id}`,
            name: Math.abs(stat1.name - stat2.name),
            quantity: Math.abs(stat1.quantity - stat2.quantity)
          }))
        ).flat(),
        remarks: row.remarks
      }))
    };

    setComparisonData((prevComparisonData) => ({
      ...prevComparisonData,
      [issuedDate]: comparisonResult
    }));
  };

  const fetchData = async () => {
    try {
      const authToken = localStorage.getItem("authToken");
  
      const summaryResponse = await fetch("http://localhost:8080/kpi/summary", {
        method: "GET",
        headers: {
          Authorization: `Bearer ${authToken}`,
        },
      });
  
      if (!summaryResponse.ok) {
        throw new Error("Failed to fetch summary data");
      }
  
      const summaryData = await summaryResponse.json();
      console.log("Fetched summary data:", summaryData);
  
      if (summaryData && summaryData.data && Array.isArray(summaryData.data)) {
        const tablesDataByIssuedDate = {};
        const yearsSet = new Set();
        summaryData.data.forEach((entry) => {
          if (!entry || !entry.IssuedDate || !entry.Projects || !entry.Status) {
            console.error("Invalid data entry found:", entry);
            return;
          }
      
          const issuedDate = new Date(entry.IssuedDate).toLocaleDateString();
          const year = new Date(entry.IssuedDate).getFullYear();
          yearsSet.add(year);
          if (!tablesDataByIssuedDate[issuedDate]) {
            tablesDataByIssuedDate[issuedDate] = {
              summary_id: entry.Summary_ID,
              columns: [],
              rows: []
            };
          }
      
          if (tablesDataByIssuedDate[issuedDate].columns.length === 0) {
            tablesDataByIssuedDate[issuedDate].columns = entry.Projects.map((project, index) => ({
              id: index + 1,
              name: project.Name,
              item: `Item ${index + 1}`,
              quantity: `Quantity ${index + 1}`
            }));
          }
      
          const processedRows = entry.Status.map((status, statusIndex) => ({
            projectName: status,
            category: "",
            status: entry.Projects.map((project, colIndex) => ({
              name: parseInt(project.Item[statusIndex], 10),
              quantity: parseInt(project.Quantity[statusIndex], 10),
              id: colIndex + 1,
              statuses: [{ name: parseInt(project.Quantity[statusIndex], 10), id: colIndex + 1 }]
            })),
            remarks: entry.Remarks && entry.Remarks[statusIndex] ? entry.Remarks[statusIndex] : "No remarks available"
          }));
      
          tablesDataByIssuedDate[issuedDate].rows.push(...processedRows);
        });
      
        setYears(Array.from(yearsSet));
        setSelectedYears(Array.from(yearsSet));
        setTablesData(tablesDataByIssuedDate);
        setEditTableData(tablesDataByIssuedDate);
      }
      
    } catch (error) {
      console.error("Error fetching data:", error.message);
    }
  };
  
  useEffect(() => {
    fetchData();
  }, []);

  const handleYearChange = (year) => {
    setSelectedYears((prevSelectedYears) =>
      prevSelectedYears.includes(year)
        ? prevSelectedYears.filter((y) => y !== year)
        : [...prevSelectedYears, year]
    );
  };

  const handleEditClick = () => {
    setEditMode(true);
  };

  const handleSaveClick = async () => {
    setEditMode(false);
  
    try {
      const authToken = localStorage.getItem("authToken");
  
      for (const [issuedDate, tableData] of Object.entries(editTableData)) {
        const summaryId = tableData.summary_id;
  
        const dataToUpdate = {
          Summary_ID: summaryId,
          IssuedDate: new Date(issuedDate).toISOString(),
          Projects: [],
          Status: [],
          Remarks: []
        };
  
        tableData.columns.forEach((col, colIndex) => {
          const projectData = {
            Project_ID: col.id,
            Name: col.name,
            Summary_ID: summaryId,
            Item: [],
            Quantity: []
          };
  
          tableData.rows.forEach((row) => {
            const status = row.status.find((status) => status.id === col.id);
            if (status) {
              projectData.Item.push(status.name);
              projectData.Quantity.push(status.quantity);
            } else {
              projectData.Item.push(0);
              projectData.Quantity.push(0);
            }
          });
  
          dataToUpdate.Projects.push(projectData);
        });
  
        tableData.rows.forEach((row) => {
          dataToUpdate.Status.push(row.projectName);
          dataToUpdate.Remarks.push(row.remarks);
        });
  
        const response = await fetch(`http://localhost:8080/kpi/summary/entire/${summaryId}`, {
          method: "PUT",
          headers: {
            Authorization: `Bearer ${authToken}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify(dataToUpdate)
        });
  
        if (!response.ok) {
          throw new Error("Failed to update summary data");
        }
      }
  
      fetchData();
    } catch (error) {
      console.error("Error updating data:", error.message);
    }
  };
  
  const handleChange = (issuedDate, rowIndex, field, value, statusIndex) => {
    const updatedTableData = { ...editTableData };
    if (statusIndex !== undefined) {
      updatedTableData[issuedDate].rows[rowIndex].status[statusIndex][field] = value;
    } else {
      updatedTableData[issuedDate].rows[rowIndex][field] = value;
    }
    setEditTableData(updatedTableData);
  };

  const handleColumnChange = (issuedDate, colIndex, field, value) => {
    const updatedTableData = { ...editTableData };
    updatedTableData[issuedDate].columns[colIndex][field] = value;
    setEditTableData(updatedTableData);
  };
  

  return (
    <div>
      {warningMessage && <div className="warning">{warningMessage}</div>}
      <div className="filter-containers">
        <div className="dropdown">
          <button onClick={toggleDropdown} className="dropdown-button">
            Pilih Tahun
          </button>
          {dropdownOpen && (
            <div className="dropdown-content">
              {years.map((year, index) => (
                <label key={index} className="dropdown-item">
                  <input
                    type="checkbox"
                    value={year}
                    checked={selectedYears.includes(year)}
                    onChange={() => handleYearChange(year)}
                  />
                  {year}
                </label>
              ))}
            </div>
          )}
        </div>
        {editMode ? (
        <button onClick={handleSaveClick}>Save Changes</button>
      ) : (
        <button onClick={handleEditClick}>Update Data</button>
      )}
      </div>



      {Object.entries(tablesData)
        .filter(([issuedDate]) => selectedYears.includes(new Date(issuedDate).getFullYear()))
        .map(([issuedDate, tableData]) => (
          <div key={issuedDate} className="table-container">
            <table className="dropdowns-safety-sum">
              <caption>Summary Table {issuedDate}</caption>
              <thead>
                <tr>
                  <th rowSpan="2">Item Category Project</th>
                  {tableData.columns.map((col, colIndex) => (
                    <th colSpan="2" key={col.id}>
                      {editMode ? (
                        <textarea
                          value={editTableData[issuedDate].columns[colIndex].name}
                          onChange={(e) =>
                            handleColumnChange(issuedDate, colIndex, "name", e.target.value)
                          }
                        />
                      ) : (
                        col.name
                      )}
                    </th>
                  ))}
                  <th rowSpan="2">Remarks</th>
                </tr>
                <tr>
                  {tableData.columns.map((col) => (
                    <React.Fragment key={col.id}>
                      <th>{col.item}</th>
                      <th>{col.quantity}</th>
                    </React.Fragment>
                  ))}
                </tr>
              </thead>
              <tbody>
              {tableData.rows.map((row, rowIndex) => (
  <tr key={rowIndex}>
    <td>
      {editMode ? (
        <input
          type="text"
          value={editTableData[issuedDate].rows[rowIndex].projectName}
          onChange={(e) => handleChange(issuedDate, rowIndex, "projectName", e.target.value)}
        />
      ) : (
        row.projectName
      )}
    </td>
    {row.status.map((stat, statIndex) => (
      <React.Fragment key={stat.id}>
        <td>
          {editMode ? (
            <input
              type="number"
              value={editTableData[issuedDate].rows[rowIndex].status[statIndex].name}
              onChange={(e) => handleChange(issuedDate, rowIndex, "name", e.target.value, statIndex)}
            />
          ) : (
            stat.name
          )}
        </td>
        <td>
          {editMode ? (
            <input
              type="number"
              value={editTableData[issuedDate].rows[rowIndex].status[statIndex].quantity}
              onChange={(e) => handleChange(issuedDate, rowIndex, "quantity", e.target.value, statIndex)}
            />
          ) : (
            stat.quantity
          )}
        </td>
      </React.Fragment>
    ))}
    <td>
      {editMode ? (
        <input
          type="text"
          value={editTableData[issuedDate].rows[rowIndex].remarks}
          onChange={(e) => handleChange(issuedDate, rowIndex, "remarks", e.target.value)}
        />
      ) : (
        row.remarks
      )}
    </td>
  </tr>
))}

              </tbody>
            </table>
            <div className="compare">
              <button onClick={() => handleCompareData(issuedDate)}>Compare Data</button>
            </div>
          </div>
        ))}

      {Object.entries(comparisonData)
        .filter(([issuedDate]) => selectedYears.includes(new Date(issuedDate).getFullYear()))
        .map(([issuedDate, compData]) => (
          <div key={issuedDate} className="table-container">
            <hr /> {/* Section line above the comparison table */}
            <h2>Data Compared</h2>
            <table className="dropdowns-safety-sum">
              <caption>Comparison Table for {issuedDate}</caption>
              <thead>
                <tr>
                  <th rowSpan="2">Item Category Project</th>
                  {compData.columns.map((col) => (
                    <th colSpan="2" key={col.id}>
                      {col.name}
                    </th>
                  ))}
                  <th rowSpan="2">Remarks</th>
                </tr>
                <tr>
                  {compData.columns.map((col) => (
                    <React.Fragment key={col.id}>
                      <th>{col.item}</th>
                      <th>{col.quantity}</th>
                    </React.Fragment>
                  ))}
                </tr>
              </thead>
              <tbody>
                {compData.rows.map((row, rowIndex) => (
                  <tr key={rowIndex}>
                    <td>{row.projectName}</td>
                    {row.status.map((stat) => (
                      <React.Fragment key={stat.id}>
                        <td>{stat.name}</td>
                        <td>{stat.quantity}</td>
                      </React.Fragment>
                    ))}
                    <td>{row.remarks}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        ))}
    </div>
  );
};

export default SavedSummaryTable;
=====
import React, { useState, useEffect } from "react";
import "../Styles/savedsummary.css";

const SavedSummaryTable = () => {
  const [columns, setColumns] = useState([]);
  const [rows, setRows] = useState([]);
  const [tablesData, setTablesData] = useState({});
  const [comparisonData, setComparisonData] = useState({});
  const [warningMessage, setWarningMessage] = useState("");
  const [years, setYears] = useState([]);
  const [selectedYears, setSelectedYears] = useState([]);
  const [dropdownOpen, setDropdownOpen] = useState(false);
  const [editMode, setEditMode] = useState(false); // state untuk mode edit
  const [editTableData, setEditTableData] = useState({}); // state untuk data yang diubah

  const toggleDropdown = () => {
    setDropdownOpen(!dropdownOpen);
  };

  const handleCompareData = (issuedDate) => {
    const currentTable = tablesData[issuedDate];

    if (currentTable.columns.length < 2) {
      alert("Untuk melakukan perbandingan minimal harus memiliki 2 nama project!");
      return;
    }

    const comparisonResult = {
      columns: currentTable.columns.map((col1, index1) =>
        currentTable.columns.slice(index1 + 1).map((col2, index2) => ({
          id: `${col1.id}-${col2.id}`,
          name: `${col1.name} vs ${col2.name}`,
          item: `Diff Item ${col1.id} vs ${col2.id}`,
          quantity: `Diff Quantity ${col1.id} vs ${col2.id}`
        }))
      ).flat(),
      rows: currentTable.rows.map((row) => ({
        projectName: row.projectName,
        status: row.status.map((stat1, index1) =>
          row.status.slice(index1 + 1).map((stat2, index2) => ({
            id: `${stat1.id}-${stat2.id}`,
            name: Math.abs(stat1.name - stat2.name),
            quantity: Math.abs(stat1.quantity - stat2.quantity)
          }))
        ).flat(),
        remarks: row.remarks
      }))
    };

    setComparisonData((prevComparisonData) => ({
      ...prevComparisonData,
      [issuedDate]: comparisonResult
    }));
  };

  const fetchData = async () => {
    try {
      const authToken = localStorage.getItem("authToken");

      const summaryResponse = await fetch("http://localhost:8080/kpi/summary", {
        method: "GET",
        headers: {
          Authorization: `Bearer ${authToken}`,
        },
      });

      if (!summaryResponse.ok) {
        throw new Error("Failed to fetch summary data");
      }

      const summaryData = await summaryResponse.json();
      console.log("Fetched summary data:", summaryData);

      if (summaryData && summaryData.data && Array.isArray(summaryData.data)) {
        const tablesDataByIssuedDate = {};
        const yearsSet = new Set();
        summaryData.data.forEach((entry) => {
          if (!entry || !entry.IssuedDate || !entry.Projects || !entry.Status) {
            console.error("Invalid data entry found:", entry);
            return;
          }

          const issuedDate = new Date(entry.IssuedDate).toLocaleDateString();
          const year = new Date(entry.IssuedDate).getFullYear();
          yearsSet.add(year);
          if (!tablesDataByIssuedDate[issuedDate]) {
            tablesDataByIssuedDate[issuedDate] = {
              summary_id: entry.Summary_ID,
              columns: [],
              rows: []
            };
          }

          if (tablesDataByIssuedDate[issuedDate].columns.length === 0) {
            tablesDataByIssuedDate[issuedDate].columns = entry.Projects.map((project, index) => ({
              id: index + 1,
              name: project.Name,
              item: `Item ${index + 1}`,
              quantity: `Quantity ${index + 1}`
            }));
          }

          const processedRows = entry.Status.map((status, statusIndex) => ({
            projectName: status,
             status: entry.Projects.map((project, colIndex) => ({
              name: parseInt(project.Item[statusIndex], 10),
              quantity: parseInt(project.Quantity[statusIndex], 10),
              id: colIndex + 1,
              statuses: [{ name: parseInt(project.Quantity[statusIndex], 10), id: colIndex + 1 }]
            })),
            remarks: entry.Remarks && entry.Remarks[statusIndex] ? entry.Remarks[statusIndex] : "No remarks available"
          }));

          tablesDataByIssuedDate[issuedDate].rows.push(...processedRows);
        });

        setYears(Array.from(yearsSet));
        setSelectedYears(Array.from(yearsSet));
        setTablesData(tablesDataByIssuedDate);
        setEditTableData(tablesDataByIssuedDate);
      }

    } catch (error) {
      console.error("Error fetching data:", error.message);
    }
  };

  useEffect(() => {
    fetchData();
  }, []);

  const handleYearChange = (year) => {
    setSelectedYears((prevSelectedYears) =>
      prevSelectedYears.includes(year)
        ? prevSelectedYears.filter((y) => y !== year)
        : [...prevSelectedYears, year]
    );
  };

  const handleEditClick = () => {
    setEditMode(true);
  };

  const handleSaveClick = async () => {
    setEditMode(false);
    try {
      const authToken = localStorage.getItem("authToken");
  
      for (const [issuedDate, tableData] of Object.entries(editTableData)) {
        const summaryId = tableData.summary_id;
  
        // Construct data for the PUT request
        const dataToUpdate = {
          Summary_ID: summaryId,
          IssuedDate: new Date(issuedDate).toISOString(),
          Projects: tableData.columns.map((col) => {
            const projectData = {
              Project_ID: col.id,
              Name: col.name,
              Summary_ID: summaryId,
              Item: [],
              Quantity: []
            };
  
            // Match row status to columns
            tableData.rows.forEach((row) => {
              const status = row.status.find((status) => status.id === col.id);
              projectData.Item.push(status ? parseInt(status.name) : 0);
              projectData.Quantity.push(status ? parseInt(status.quantity) : 0);
            });
  
            return projectData;
          }),
          Status: tableData.rows.map(row => row.projectName),
          Remarks: tableData.rows.map(row => row.remarks)
        };
  
        // Execute the PUT request
        let response = await fetch(`http://localhost:8080/kpi/summary/entire/${summaryId}`, {
          method: "PUT",
          headers: {
            Authorization: `Bearer ${authToken}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify(dataToUpdate)
        });
  
        if (!response.ok) {
          throw new Error("Failed to update summary data");
        }
  
        // Construct and execute POST requests for new rows
        const newRows = tableData.rows.filter(row => row.isNew);
        for (const newRow of newRows) {
          const projectsData = tableData.columns.map((col) => ({
            Project_ID: col.id,
            Name: newRow.projectName,
            Item: newRow.status.find(s => s.id === col.id) ? parseInt(newRow.status.find(s => s.id === col.id).name) : 0,
            Quantity: newRow.status.find(s => s.id === col.id) ? parseInt(newRow.status.find(s => s.id === col.id).quantity) : 0,
            Summary_ID: summaryId
          }));
  
          const postData = {
            Summary_ID: summaryId,
            IssuedDate: new Date(issuedDate).toISOString(),
            Projects: projectsData,
            Status: newRow.projectName,
            Remarks: newRow.remarks
          };
  
          response = await fetch(`http://localhost:8080/kpi/summary/entire`, {
            method: "POST",
            headers: {
              Authorization: `Bearer ${authToken}`,
              "Content-Type": "application/json"
            },
            body: JSON.stringify(postData)
          });
  
          if (!response.ok) {
            throw new Error("Failed to add new row data");
          }
        }
      }
  
      fetchData(); // Refresh data after updates
    } catch (error) {
      console.error("Error updating data:", error.message);
    }
  };
  
  const handleAddColumnClick = (issuedDate) => {
    const newColumn = {
      id: editTableData[issuedDate].columns.length + 1,
      name: "", // Empty name initially
      item: `Item ${editTableData[issuedDate].columns.length + 1}`,
      quantity: `Quantity ${editTableData[issuedDate].columns.length + 1}`
    };
  
    const updatedTableData = { ...editTableData };
    updatedTableData[issuedDate].columns.push(newColumn);
  
    // Update Projects with the new column name
    updatedTableData[issuedDate].rows.forEach(row => {
      row.status.push({
        name: "", // Empty name initially
        quantity: "",
        id: newColumn.id,
        statuses: [{ name: 0, id: newColumn.id }] // Ensure initial status
      });
    });
  
    setEditTableData(updatedTableData);
  };
  
  

  const handleChange = (issuedDate, rowIndex, field, value, statusIndex) => {
    const updatedTableData = { ...editTableData };
    if (statusIndex !== undefined) {
      updatedTableData[issuedDate].rows[rowIndex].status[statusIndex][field] = value;
    } else {
      updatedTableData[issuedDate].rows[rowIndex][field] = value;
    }
    setEditTableData(updatedTableData);
  };

  const handleColumnChange = (issuedDate, colIndex, field, value) => {
    const updatedTableData = { ...editTableData };
    updatedTableData[issuedDate].columns[colIndex][field] = value;
    setEditTableData(updatedTableData);
  };

  const handleAddRowClick = (issuedDate) => {
    const newRow = {
      projectName: "",
       status: editTableData[issuedDate].columns.map((col) => ({
        name: "",
        quantity: "",
        id: col.id,
      })),
      remarks: "",
     };
  
    const updatedTableData = { ...editTableData };
    updatedTableData[issuedDate].rows.push(newRow);
    setEditTableData(updatedTableData);
  };
  
  const handleDeleteProject = (issuedDate, projectId) => {
    const updatedTableData = { ...editTableData };
    updatedTableData[issuedDate].columns = updatedTableData[issuedDate].columns.filter(col => col.id !== projectId);
    updatedTableData[issuedDate].rows.forEach(row => {
      row.status = row.status.filter(stat => stat.id !== projectId);
    });
    setEditTableData(updatedTableData);
  };


  return (
    <div>
      {warningMessage && <div className="warning">{warningMessage}</div>}
      <div className="filter-containers">
        <div className="dropdown">
          <button onClick={toggleDropdown} className="dropdown-button">
            Pilih Tahun
          </button>
          {dropdownOpen && (
            <div className="dropdown-content">
              {years.map((year, index) => (
                <label key={index} className="dropdown-item">
                  <input
                    type="checkbox"
                    value={year}
                    checked={selectedYears.includes(year)}
                    onChange={() => handleYearChange(year)}
                  />
                  {year}
                </label>
              ))}
            </div>
          )}
        </div>
        {editMode ? (
        <button onClick={handleSaveClick}>Save Changes</button>
      ) : (
        <button onClick={handleEditClick}>Update Data</button>
      )}
      </div>



      {Object.entries(tablesData)
        .filter(([issuedDate]) => selectedYears.includes(new Date(issuedDate).getFullYear()))
        .map(([issuedDate, tableData]) => (
          <div key={issuedDate} className="table-container">
            <table className="dropdowns-safety-sum">
              <caption>Summary Table {issuedDate}</caption>
              <thead>
                <tr>
                  <th rowSpan="2">Item Category Project
                  <div >
                  {editMode && (
              <React.Fragment>
                <button style={{ marginTop:"10px"}} onClick={() => handleAddRowClick(issuedDate)}>Add Project</button>
                <button style={{ marginTop:"5px", marginLeft:"5px"}} onClick={() => handleAddColumnClick(issuedDate)}>Add Status</button>
                {editTableData[issuedDate].columns.map(col => (
                <button
                  key={col.id}
                  style={{ marginTop: "5px", marginLeft: "5px" }}
                  onClick={() => handleDeleteProject(issuedDate, col.id)}
                >
                  Delete {col.name}
                </button>
              ))}
              </React.Fragment>
)}

              </div>
              </th>
                  {tableData.columns.map((col, colIndex) => (
                    <th colSpan="2" key={col.id}>
                      {editMode ? (
                        <textarea
                          value={editTableData[issuedDate].columns[colIndex].name}
                          onChange={(e) =>
                            handleColumnChange(issuedDate, colIndex, "name", e.target.value)
                          }
                        />
                      ) : (
                        col.name
                      )}
                    </th>
                  ))}
                  <th rowSpan="2">Remarks</th>
                </tr>
                <tr>
                  {tableData.columns.map((col) => (
                    <React.Fragment key={col.id}>
                      <th>{col.item}</th>
                      <th>{col.quantity}</th>
                    </React.Fragment>
                  ))}
                </tr>
              </thead>
              <tbody>
              {tableData.rows.map((row, rowIndex) => (
  <tr key={rowIndex}>
    
    <td>
      {editMode ? (
        <input
          type="text"
          value={editTableData[issuedDate].rows[rowIndex].projectName}
          onChange={(e) => handleChange(issuedDate, rowIndex, "projectName", e.target.value)}
        />
      ) : (
        row.projectName
      )}
    </td>
    {row.status.map((stat, statIndex) => (
      <React.Fragment key={stat.id}>
        <td>
          {editMode ? (
            <input
              type="number"
              value={editTableData[issuedDate].rows[rowIndex].status[statIndex].name}
              onChange={(e) => handleChange(issuedDate, rowIndex, "name", e.target.value, statIndex)}
            />
          ) : (
            stat.name
          )}
        </td>
        <td>
          {editMode ? (
            <input
              type="number"
              value={editTableData[issuedDate].rows[rowIndex].status[statIndex].quantity}
              onChange={(e) => handleChange(issuedDate, rowIndex, "quantity", e.target.value, statIndex)}
            />
          ) : (
            stat.quantity
          )}
        </td>
      </React.Fragment>
    ))}
    <td>
      {editMode ? (
        <input
          type="text"
          value={editTableData[issuedDate].rows[rowIndex].remarks}
          onChange={(e) => handleChange(issuedDate, rowIndex, "remarks", e.target.value)}
        />
      ) : (
        row.remarks
      )}
    </td>
  </tr>
))}

              </tbody>
            </table>
            <div className="compare">
              <button onClick={() => handleCompareData(issuedDate)}>Compare Data</button>
            </div>
          </div>
        ))}

      {Object.entries(comparisonData)
        .filter(([issuedDate]) => selectedYears.includes(new Date(issuedDate).getFullYear()))
        .map(([issuedDate, compData]) => (
          <div key={issuedDate} className="table-container">
            <hr /> {/* Section line above the comparison table */}
            <h2>Data Compared</h2>
            <table className="dropdowns-safety-sum">
              <caption>Comparison Table for {issuedDate}</caption>
              <thead>
                <tr>
                  <th rowSpan="2">Item Category Project</th>
                  {compData.columns.map((col) => (
                    <th colSpan="2" key={col.id}>
                      {col.name}
                    </th>
                  ))}
                  <th rowSpan="2">Remarks</th>
                </tr>
                <tr>
                  {compData.columns.map((col) => (
                    <React.Fragment key={col.id}>
                      <th>{col.item}</th>
                      <th>{col.quantity}</th>
                    </React.Fragment>
                  ))}
                </tr>
              </thead>
              <tbody>
                {compData.rows.map((row, rowIndex) => (
                  <tr key={rowIndex}>
                    <td>{row.projectName}</td>
                    {row.status.map((stat) => (
                      <React.Fragment key={stat.id}>
                        <td>{stat.name}</td>
                        <td>{stat.quantity}</td>
                      </React.Fragment>
                    ))}
                    <td>{row.remarks}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        ))}
    </div>
  );
};

export default SavedSummaryTable;

=====
FINAL

import React, { useState, useEffect } from "react";
import "../Styles/savedsummary.css";

const SavedSummaryTable = () => {
  const [columns, setColumns] = useState([]);
  const [rows, setRows] = useState([]);
  const [tablesData, setTablesData] = useState({});
  const [comparisonData, setComparisonData] = useState({});
  const [warningMessage, setWarningMessage] = useState("");
  const [years, setYears] = useState([]);
  const [selectedYears, setSelectedYears] = useState([]);
  const [dropdownOpen, setDropdownOpen] = useState(false);
  const [editMode, setEditMode] = useState(false); // state untuk mode edit
  const [editTableData, setEditTableData] = useState({}); // state untuk data yang diubah

  const toggleDropdown = () => {
    setDropdownOpen(!dropdownOpen);
  };

  const handleCompareData = (issuedDate) => {
    const currentTable = tablesData[issuedDate];

    if (currentTable.columns.length < 2) {
      alert("Untuk melakukan perbandingan minimal harus memiliki 2 nama project!");
      return;
    }

    const comparisonResult = {
      columns: currentTable.columns.map((col1, index1) =>
        currentTable.columns.slice(index1 + 1).map((col2, index2) => ({
          id: `${col1.id}-${col2.id}`,
          name: `${col1.name} vs ${col2.name}`,
          item: `Diff Item ${col1.id} vs ${col2.id}`,
          quantity: `Diff Quantity ${col1.id} vs ${col2.id}`
        }))
      ).flat(),
      rows: currentTable.rows.map((row) => ({
        projectName: row.projectName,
        status: row.status.map((stat1, index1) =>
          row.status.slice(index1 + 1).map((stat2, index2) => ({
            id: `${stat1.id}-${stat2.id}`,
            name: Math.abs(stat1.name - stat2.name),
            quantity: Math.abs(stat1.quantity - stat2.quantity)
          }))
        ).flat(),
        remarks: row.remarks
      }))
    };

    setComparisonData((prevComparisonData) => ({
      ...prevComparisonData,
      [issuedDate]: comparisonResult
    }));
  };

 
  const handleDeleteRow = (issuedDate, projectName) => {
    const updatedTableData = { ...editTableData };
    updatedTableData[issuedDate].rows = updatedTableData[issuedDate].rows.filter(
      (row) => row.projectName !== projectName
    );
    setEditTableData(updatedTableData);
  };

  const fetchData = async () => {
    try {
      const authToken = localStorage.getItem("authToken");

      const summaryResponse = await fetch("http://localhost:8080/kpi/summary", {
        method: "GET",
        headers: {
          Authorization: `Bearer ${authToken}`,
        },
      });

      if (!summaryResponse.ok) {
        throw new Error("Failed to fetch summary data");
      }

      const summaryData = await summaryResponse.json();
      console.log("Fetched summary data:", summaryData);

      if (summaryData && summaryData.data && Array.isArray(summaryData.data)) {
        const tablesDataByIssuedDate = {};
        const yearsSet = new Set();
        summaryData.data.forEach((entry) => {
          if (!entry || !entry.IssuedDate || !entry.Projects || !entry.Status) {
            console.error("Invalid data entry found:", entry);
            return;
          }

          const issuedDate = new Date(entry.IssuedDate).toLocaleDateString();
          const year = new Date(entry.IssuedDate).getFullYear();
          yearsSet.add(year);
          if (!tablesDataByIssuedDate[issuedDate]) {
            tablesDataByIssuedDate[issuedDate] = {
              summary_id: entry.Summary_ID,
              columns: [],
              rows: []
            };
          }

          if (tablesDataByIssuedDate[issuedDate].columns.length === 0) {
            tablesDataByIssuedDate[issuedDate].columns = entry.Projects.map((project, index) => ({
              id: index + 1,
              name: project.Name,
              item: `Item ${index + 1}`,
              quantity: `Quantity ${index + 1}`
            }));
          }

          const processedRows = entry.Status.map((status, statusIndex) => ({
            projectName: status,
             status: entry.Projects.map((project, colIndex) => ({
              name: parseInt(project.Item[statusIndex], 10),
              quantity: parseInt(project.Quantity[statusIndex], 10),
              id: colIndex + 1,
              statuses: [{ name: parseInt(project.Quantity[statusIndex], 10), id: colIndex + 1 }]
            })),
            remarks: entry.Remarks && entry.Remarks[statusIndex] ? entry.Remarks[statusIndex] : "No remarks available"
          }));

          tablesDataByIssuedDate[issuedDate].rows.push(...processedRows);
        });

        setYears(Array.from(yearsSet));
        setSelectedYears(Array.from(yearsSet));
        setTablesData(tablesDataByIssuedDate);
        setEditTableData(tablesDataByIssuedDate);
      }

    } catch (error) {
      console.error("Error fetching data:", error.message);
    }
  };

  useEffect(() => {
    fetchData();
  }, []);

  const handleYearChange = (year) => {
    setSelectedYears((prevSelectedYears) =>
      prevSelectedYears.includes(year)
        ? prevSelectedYears.filter((y) => y !== year)
        : [...prevSelectedYears, year]
    );
  };

  const handleEditClick = () => {
    setEditMode(true);
  };

  const handleSaveClick = async () => {
    setEditMode(false);
    try {
      const authToken = localStorage.getItem("authToken");
  
      for (const [issuedDate, tableData] of Object.entries(editTableData)) {
        const summaryId = tableData.summary_id;
  
        // Construct data for the PUT request
        const dataToUpdate = {
          Summary_ID: summaryId,
          IssuedDate: new Date(issuedDate).toISOString(),
          Projects: tableData.columns.map((col) => {
            const projectData = {
              Project_ID: col.id,
              Name: col.name,
              Summary_ID: summaryId,
              Item: [],
              Quantity: []
            };
  
            // Match row status to columns
            tableData.rows.forEach((row) => {
              const status = row.status.find((status) => status.id === col.id);
              projectData.Item.push(status ? parseInt(status.name) : 0);
              projectData.Quantity.push(status ? parseInt(status.quantity) : 0);
            });
  
            return projectData;
          }),
          Status: tableData.rows.map(row => row.projectName),
          Remarks: tableData.rows.map(row => row.remarks)
        };
  
        // Execute the PUT request
        let response = await fetch(`http://localhost:8080/kpi/summary/entire/${summaryId}`, {
          method: "PUT",
          headers: {
            Authorization: `Bearer ${authToken}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify(dataToUpdate)
        });
  
        if (!response.ok) {
          throw new Error("Failed to update summary data");
        }
  
        // Construct and execute POST requests for new rows
        const newRows = tableData.rows.filter(row => row.isNew);
        for (const newRow of newRows) {
          const projectsData = tableData.columns.map((col) => ({
            Project_ID: col.id,
            Name: newRow.projectName,
            Item: newRow.status.find(s => s.id === col.id) ? parseInt(newRow.status.find(s => s.id === col.id).name) : 0,
            Quantity: newRow.status.find(s => s.id === col.id) ? parseInt(newRow.status.find(s => s.id === col.id).quantity) : 0,
            Summary_ID: summaryId
          }));
  
          const postData = {
            Summary_ID: summaryId,
            IssuedDate: new Date(issuedDate).toISOString(),
            Projects: projectsData,
            Status: newRow.projectName,
            Remarks: newRow.remarks
          };
  
          response = await fetch(`http://localhost:8080/kpi/summary/entire`, {
            method: "POST",
            headers: {
              Authorization: `Bearer ${authToken}`,
              "Content-Type": "application/json"
            },
            body: JSON.stringify(postData)
          });
  
          if (!response.ok) {
            throw new Error("Failed to add new row data");
          }
        }
      }
  
      fetchData(); // Refresh data after updates
    } catch (error) {
      console.error("Error updating data:", error.message);
    }
  };
  
  const handleAddColumnClick = (issuedDate) => {
    const newColumn = {
      id: editTableData[issuedDate].columns.length + 1,
      name: "", // Empty name initially
      item: `Item ${editTableData[issuedDate].columns.length + 1}`,
      quantity: `Quantity ${editTableData[issuedDate].columns.length + 1}`
    };
  
    const updatedTableData = { ...editTableData };
    updatedTableData[issuedDate].columns.push(newColumn);
  
    // Update Projects with the new column name
    updatedTableData[issuedDate].rows.forEach(row => {
      row.status.push({
        name: "", // Empty name initially
        quantity: "",
        id: newColumn.id,
        statuses: []
      });
    });
  
    setEditTableData(updatedTableData);
  };
  
  const handleAddRowClick = (issuedDate) => {
    const newRow = {
      projectName: "",
      status: editTableData[issuedDate].columns.map((col) => ({
        name: "", // Empty name initially
        quantity: "",
        id: col.id,
        statuses: []
      })),
      remarks: ""
    };
  
    const updatedTableData = { ...editTableData };
    updatedTableData[issuedDate].rows.push(newRow);
    setEditTableData(updatedTableData);
  };
  
  const handleColumnChange = (issuedDate, colIndex, field, value) => {
    const updatedTableData = { ...editTableData };
    updatedTableData[issuedDate].columns[colIndex][field] = value;
    setEditTableData(updatedTableData);
  };
  
  const handleChange = (issuedDate, rowIndex, field, value, statIndex = null) => {
    const updatedTableData = { ...editTableData };
    if (statIndex === null) {
      updatedTableData[issuedDate].rows[rowIndex][field] = value;
    } else {
      updatedTableData[issuedDate].rows[rowIndex].status[statIndex][field] = value;
    }
    setEditTableData(updatedTableData);
  };
  
  const handleDeleteProject = (issuedDate, projectId) => {
    const updatedTableData = { ...editTableData };
    updatedTableData[issuedDate].columns = updatedTableData[issuedDate].columns.filter(col => col.id !== projectId);
    updatedTableData[issuedDate].rows.forEach(row => {
      row.status = row.status.filter(stat => stat.id !== projectId);
    });
    setEditTableData(updatedTableData);
  };
  
  return (
    <div>
      {warningMessage && <div className="warning">{warningMessage}</div>}
      <div className="filter-containers">
        <div className="dropdown">
          <button onClick={toggleDropdown} className="dropdown-button">
            Pilih Tahun
          </button>
          {dropdownOpen && (
            <div className="dropdown-content">
              {years.map((year, index) => (
                <label key={index} className="dropdown-item">
                  <input
                    type="checkbox"
                    value={year}
                    checked={selectedYears.includes(year)}
                    onChange={() => handleYearChange(year)}
                  />
                  {year}
                </label>
              ))}
            </div>
          )}
        </div>
        {editMode ? (
          <button onClick={handleSaveClick}>Save Changes</button>
        ) : (
          <button onClick={handleEditClick}>Update Data</button>
        )}
      </div>
  
      {Object.entries(tablesData)
        .filter(([issuedDate]) => selectedYears.includes(new Date(issuedDate).getFullYear()))
        .map(([issuedDate, tableData]) => (
          <div key={issuedDate} className="table-container">
            <table className="dropdowns-safety-sum">
              <caption>Summary Table {issuedDate}</caption>
              <thead>
                <tr>
                  <th rowSpan="2">
                    Item Category Project
                    <div>
                    {editMode && (
                      <React.Fragment>
                        <button
                          style={{ marginTop: "10px" }}
                          onClick={() => handleAddRowClick(issuedDate)}
                        >
                          Add Project
                        </button>
                        <button
                          style={{ marginTop: "5px", marginLeft: "5px" }}
                          onClick={() => handleAddColumnClick(issuedDate)}
                        >
                          Add Status
                        </button>
                      </React.Fragment>
                    )}
                    </div>
                  </th>
                  {tableData.columns.map((col, colIndex) => (
                    <th colSpan="2" key={col.id}>
                      {editMode ? (
                        <textarea
                          value={editTableData[issuedDate].columns[colIndex].name}
                          onChange={(e) =>
                            handleColumnChange(
                              issuedDate,
                              colIndex,
                              "name",
                              e.target.value
                            )
                          }
                        />
                      ) : (
                        col.name
                      )}
                      <div>
                      {editMode && (
                        <button
                          style={{ marginLeft: "10px" }}
                          onClick={() => handleDeleteProject(issuedDate, col.id)}
                        >
                          Delete
                        </button>
                      )}
                      </div>
                    </th>
                  ))}
                  <th rowSpan="2">Remarks</th>
                </tr>
                <tr>
                  {tableData.columns.map((col) => (
                    <React.Fragment key={col.id}>
                      <th>{col.item}</th>
                      <th>{col.quantity}</th>
                    </React.Fragment>
                  ))}
                </tr>
              </thead>
              <tbody>
                {tableData.rows.map((row, rowIndex) => (
                  <tr key={rowIndex}>
                    <td>
                      {editMode ? (
                        <input
                          type="text"
                          value={editTableData[issuedDate].rows[rowIndex].projectName}
                          onChange={(e) =>
                            handleChange(
                              issuedDate,
                              rowIndex,
                              "projectName",
                              e.target.value
                            )
                          }
                        />
                      ) : (
                        row.projectName
                      )}
                         {editMode && (
                        <button onClick={() => handleDeleteRow(issuedDate, row.projectName)}>
                          Delete
                        </button>
                      )}
                    </td>
                    {row.status.map((stat, statIndex) => (
                      <React.Fragment key={stat.id}>
                        <td>
                          {editMode ? (
                            <input
                              type="number"
                              value={editTableData[issuedDate].rows[rowIndex].status[statIndex].name}
                              onChange={(e) =>
                                handleChange(
                                  issuedDate,
                                  rowIndex,
                                  "name",
                                  e.target.value,
                                  statIndex
                                )
                              }
                            />
                          ) : (
                            stat.name
                          )}
                        </td>
                        <td>
                          {editMode ? (
                            <input
                              type="number"
                              value={editTableData[issuedDate].rows[rowIndex].status[statIndex].quantity}
                              onChange={(e) =>
                                handleChange(
                                  issuedDate,
                                  rowIndex,
                                  "quantity",
                                  e.target.value,
                                  statIndex
                                )
                              }
                            />
                          ) : (
                            stat.quantity
                          )}
                        </td>
                      </React.Fragment>
                    ))}
                    <td>
                      {editMode ? (
                        <input
                          type="text"
                          value={editTableData[issuedDate].rows[rowIndex].remarks}
                          onChange={(e) =>
                            handleChange(
                              issuedDate,
                              rowIndex,
                              "remarks",
                              e.target.value
                            )
                          }
                        />
                      ) : (
                        row.remarks
                      )}
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
            <div className="compare">
            <button onClick={() => handleCompareData(issuedDate)}>Compare Data</button>
            </div>
          </div>
        ))}
    </div>
  );
};

export default SavedSummaryTable;
